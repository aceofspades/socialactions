<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><title>Class: Fixtures</title><link type="text/css" href=".././rdoc-style.css" media="screen" rel="stylesheet"/><script type="text/javascript">
// Allison template
// Copyright 2007, 2008 Cloudburst, LLC. Licensed under the AFL 3. See the included LICENSE file.

var href_base = '.././rdoc-style.css'.replace(/(.*\/).*/, '$1'); // inline js is good for something  

function $(id) {
    if (document.getElementById)
      elem = document.getElementById(id);
    else if ( document.all )
      elem = eval("document.all." + id);
    else
      return false;
    return elem;
}

  function toggle(id) {
    elem = $(id);
    elemStyle = elem.style;   
    if (elemStyle.display == "block") {
      elemStyle.display = "none"
    } else {
      elemStyle.display = "block"
    }
    return true;
  }

  function toggleText(id) {
    elem = $(id)
    if (m = elem.innerHTML.match(/(Hide)(.*)/)) {
      elem.innerHTML = "Show" + m[2];
    } else if (m = elem.innerHTML.match(/(Show)(.*)/)) {
      elem.innerHTML = "Hide" + m[2];
    }
    return true;
  }

function span(s, klass) {
  return '<span class="' + klass + '">' + s + '</span>';
}
  
function highlightSymbols() {
  pres = document.getElementsByTagName('pre');
  for(var i = 0; i < pres.length; i++) {
    pre = pres[i];
    spans = pre.getElementsByTagName('span');
    for(var k = 0; k < spans.length; k++) {
      span = spans[k];
      if (span.className.match(/ruby-identifier/)) {
        if (span.innerHTML.match(/^:/)) {
          span.className += " ruby-symbol";
        }
      }
    }
  }
}

 function hasClass(obj) {
     var result = false;
     if (obj.getAttributeNode("class") != null) {
         result = obj.getAttributeNode("class").value;
     }
     return result;
  }   

 function stripe() {
    var even = true;
    var color = "#e4ebed";
    var tables = document.getElementsByTagName('table');
    if (tables.length == 0) { return; }
    for (var h = 0; h < tables.length; h++) {
        var trs = tables[h].getElementsByTagName("tr");
        for (var i = 0; i < trs.length; i++) {
          var tds = trs[i].getElementsByTagName("td");
            for (var j = 0; j < tds.length; j++) {       
              if (hasClass(tds[j]) != "first") {                
              var mytd = tds[j];
              if (even) {
                mytd.style.backgroundColor = color;
              }         
            }
          }
          even =  ! even;
      }
    }
  }
  
function ajaxGet(url) {
  url = (href_base + url).replace('/./', '/')
  var req = false;

  if (window.ActiveXObject) {
    try {
      // stupid hack because IE7 disables local Ajax with the native xmlhttprequest object
      // for security purposes. Yet ActiveX still works. Thanks, Microsoft. I hate you. Die.
      req = new ActiveXObject("MSXML2.XMLHTTP.3.0");
    } catch (e) {
      try {
        /* IE 6 and maybe 5, don't know, don't care */
        req = new ActiveXObject("Msxml2.XMLHTTP");
      } catch (e) {
        try {
          req = new ActiveXObject("Microsoft.XMLHTTP");
        } catch (e) {
          req = false;
        }
      }
    }
  }
    
  /* real browsers */
  if (!req && window.XMLHttpRequest) {
    try {
      req = new XMLHttpRequest();
    } catch (e) {
      req = false;
    }
  } 
  
  if (req) {
    req.open('GET', url, false);
    req.send(null);
    return req.responseText;
  } else {
    return "Ajax error";  
  }
}


function addEvent(elm, evType, fn, useCapture) {
	if (elm.addEventListener) {
	  elm.addEventListener(evType, fn, useCapture);  
  	return true;
	} else if (elm.attachEvent) {
  	var r = elm.attachEvent('on' + evType, fn);  
	  return r;  
	} else {
  	elm['on' + evType] = fn;
	}
}

function insertIndices() {
  pages = ["class", "file", "method"]
  for (x in pages) { 
    $(pages[x]).innerHTML += ajaxGet('fr_' + pages[x] + '_index.html').replace(/(href=")/g, '$1' + href_base);
  }
  /* mouseoverify method links */
  links = $('method').getElementsByTagName('a');
  for (var x = 0; x < links.length; x++) {
    if (m = links[x].innerHTML.match(/(.*)\s\((.*)\)/)) {
      links[x].innerHTML = m[1] + '<br>';
      links[x].title = m[2];
    }
  }
  /* this is stupid */
  $('class').style.display = "block";
  $('file').style.display = "block";
  
  /* has to be here because IE7 does not guarantee the onLoad callback order */
  abbreviateIndicesInner(["class", "file"], 25, "a");
  /* same, linkTitle() depends on the class link list */
  linkTitle();
}

function abbreviateIndices() {
  var ids = ["defined_in", "child_of", "includes", "requires", "method", "methods"];
  abbreviateIndicesInner(ids, 25, 'a');
  abbreviateIndicesInner(ids, 25, 'span');
}

function abbreviateIndicesInner(indices, amount, tag) {
  for (var x = 0; x < indices.length; x++) { 
    var the_index = $(indices[x]);
    if (the_index) {
      links = the_index.getElementsByTagName(tag);
      for (var y = 0; y < links.length; y++) {
        var link = links[y];
        if (link.getElementsByTagName('span').length == 0 && link.getElementsByTagName('a').length == 0) {
          // avoid nesting
          link.innerHTML = link.innerHTML.replace(/<br>|\n/gi, '');
          link.title = link.innerHTML;
          link.innerHTML = abbreviate(link.innerHTML, amount) + '<br>';
        }
      }
    }
  }
}

function linkTitle() {
  
  /* grab the correct title element from the index */
  var index_page = ajaxGet('index.html');
  title_text = index_page.match(/<title>(.*)<\/title>/m)[1];
  document.title = title_text + " - " + document.title;
  var p = $('header').getElementsByTagName('p')[0]
  if (p.innerHTML.match(/^\s*$/)) {
    p.innerHTML = title_text;
  } else {
    p.innerHTML = title_text + ": " + p.innerHTML;
  }
  
  /* set the link properly */
  title_link = index_page.match(/<a\s+href="(.*?)"/)[1];
  var element = $('title');
  var item_type = "";
  var item_name = "";
  if (m = element.innerHTML.match(/(Class:|Module:|File:)\s*(.*)/)) {
    item_type = m[1];
    item_name = m[2];
  } else {
    item_name = element.innerHTML;
  }
  element.innerHTML = '<a href="' + href_base + title_link + '">' + item_type + " " + abbreviate(item_name, 45) + '</a>';
  element.getElementsByTagName('a')[0].title = item_name
  
  /* breadcrumb navigation */
  items = item_name.split("::");
  items_new = item_name.split("::");
  file_links = $('class').getElementsByTagName('a');
  for (var x = 0; x < items.length - 1; x++ ){
    var item = items[x];
    link = ("/classes/" + items.slice(0,x).join("/") + "/" + item + ".html").replace('//', '/');
    regex = new RegExp(RegExp.escape(link) + '$');
    for (var y = 0; y < file_links.length; y++) {
      if (file_links[y].href.match(regex)) {
         items_new[x] = '<a href="' + href_base + link + '">' + item + '</a>';
         break;
      }
    }  
  }
  $('item_name').innerHTML = item_type + ' ' + items_new.join(" :: ");
}

function abbreviate(s, size) {
  while (s.length > size) {
    var old_s = s;
    s = s.replace(/\s|\n/mg, '');
    s = s.replace(/([A-Z])[a-z]+/m, '$1');
    if (!s || old_s == s) {
      return "..." + s.substring(s.length - size, s.length);
    }
  }
  return s;
}

function disableSubmit(event) {
  var keyCode = event.keyCode ? event.keyCode : event.which ? event.which : event.charCode;
  if (keyCode == 13) {
    return false;
  } else {
    return true;
  }
}
  
function filterList(id, s, event) {
  
  /* some weak escaping */
  s = s.replace(/[^\w\d\.\_\-\/\:\=\[\]\?\!]/g, '');
  s = RegExp.escape(s);
  
  var show_all = false;
  if (s.match(/^\s*$/)) {
    show_all = true;
  }
  
  links = $(id).getElementsByTagName('a')
  regex = new RegExp(s, 'i');
  
  for (var x = 0; x < links.length; x++) {
    var link = links[x];
    if (show_all) {
      link.style.display = 'inline';
    } else {
       if (link.innerHTML.match(regex)) {        
         link.style.display = 'inline';
       } else {
         link.style.display = 'none';
       }
    }
  }
  return true;
}

RegExp.escape = function(text) {
  if (!arguments.callee.sRE) {
    var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];
    arguments.callee.sRE = new RegExp(
      '(\\' + specials.join('|\\') + ')', 'g'
    );
  }
  return text.replace(arguments.callee.sRE, '\\$1');
}

function hacks() {
  // show the spacer if necessary, 
  divs = document.getElementsByTagName('div');
  for(var x = 0; x < divs.length; x++) {
    if (divs[x].className && divs[x].className.match(/top/)) {
      document.getElementById('spacer').style.display = 'block';
    }
  }
  // remove extra colons from tables
  tds = document.getElementsByTagName('td');
  for(var x = 0; x < tds.length; x++) {
    str = tds[x].innerHTML
    if (str.charAt(str.length - 1) == ":") {
      tds[x].innerHTML = str.slice(0, str.length - 1)
    }
  }
}

addEvent(window, 'load', insertIndices, false);
addEvent(window, 'load', abbreviateIndices, false);
addEvent(window, 'load', stripe, false);
addEvent(window, 'load', highlightSymbols, false);
addEvent(window, 'load', hacks, false);
</script></head><body><div id="container"><div class="curve" id="preheader_curve_0"></div><div class="curve" id="preheader_curve_1"></div><div class="curve" id="preheader_curve_2"></div><div class="curve" id="preheader_curve_3"></div><div class="curve" id="preheader_curve_4"></div><div class="curve" id="preheader_curve_5"></div><div id="header"><p>
</p><span><h1 id="title">
Class: Fixtures
</h1></span>
</div><div class="clear"></div><div id="left">
<div class="navigation darker top" id="child_of"><h3>Child of</h3><span>

(RUBY_VERSION &lt; '1.9' ? YAML::Omap : Hash)
</span></div>

<div class="navigation darker top" id="defined_in"><h3>Defined in</h3>

<a href="../files/vendor/rails/activerecord/lib/active_record/fixtures_rb.html">vendor/rails/activerecord/lib/active_record/fixtures.rb</a>

</div>



<div class="navigation top" id="methods"><h3>Methods</h3>


<a href='#M000189'>
cache_fixtures<br/>
</a>




<a href='#M000186'>
cache_for_connection<br/>
</a>




<a href='#M000188'>
cached_fixtures<br/>
</a>




<a href='#M000192'>
create_fixtures<br/>
</a>




<a href='#M000195'>
delete_existing_fixtures<br/>
</a>




<a href='#M000187'>
fixture_is_cached?<br/>
</a>




<a href='#M000193'>
identify<br/>
</a>




<a href='#M000196'>
insert_fixtures<br/>
</a>




<a href='#M000191'>
instantiate_all_loaded_fixtures<br/>
</a>




<a href='#M000190'>
instantiate_fixtures<br/>
</a>




<a href='#M000194'>
new<br/>
</a>




<a href='#M000185'>
reset_cache<br/>
</a>


</div>
<div id="spacer"></div><div class="navigation darker index" id="class_wrapper"><div class="list_header"><h3>All classes</h3></div><div class="list_header_link"><a onclick="toggle('class'); toggleText('class_link'); return false;" href="#" id="class_link">Hide...</a></div><div class="clear"></div><div id="class"><form><label for="filter_class">Filter:&nbsp;&nbsp;</label><input type="text" onKeyUp="return filterList('class', this.value, event);" onKeyPress="return disableSubmit(event);" id="filter_class"></input></form></div></div><div class="navigation darker index" id="file_wrapper"><div class="list_header"><h3>All files</h3></div><div class="list_header_link"><a onclick="toggle('file'); toggleText('file_link'); return false;" href="#" id="file_link">Hide...</a></div><div class="clear"></div><div id="file"><form><label for="filter_file">Filter:&nbsp;&nbsp;</label><input type="text" onKeyUp="return filterList('file', this.value, event);" onKeyPress="return disableSubmit(event);" id="filter_file"></input></form></div></div><div class="navigation darker index" id="method_wrapper"><div class="list_header"><h3>All methods</h3></div><div class="list_header_link"><a onclick="toggle('method'); toggleText('method_link'); return false;" href="#" id="method_link">Show...</a></div><div class="clear"></div><div id="method"><form><label for="filter_method">Filter:&nbsp;&nbsp;</label><input type="text" onKeyUp="return filterList('method', this.value, event);" onKeyPress="return disableSubmit(event);" id="filter_method"></input></form></div></div></div><div id="content">
<h1 id="item_name">Class: Fixtures</h1>

<div id="description"><p>
<a href="Fixtures.html">Fixtures</a> are a way of organizing data that you
want to test against; in short, sample data. They come in 3 flavors:
</p>
<pre>
  1.  YAML fixtures
  2.  CSV fixtures
  3.  Single-file fixtures
</pre>
<h1>YAML fixtures</h1>
<p>
This type of fixture is in YAML format and the preferred default. YAML is a
file format which describes data structures in a non-verbose,
human-readable format. It ships with Ruby 1.8.1+.
</p>
<p>
Unlike single-file fixtures, YAML fixtures are stored in a single file per
model, which are placed in the directory appointed by
<tt>ActiveSupport::TestCase.fixture_path=(path)</tt> (this is automatically
configured for <a href="Rails.html">Rails</a>, so you can just put your
files in &lt;your-rails-app&gt;/test/fixtures/). The fixture file ends with
the .yml file extension (<a href="Rails.html">Rails</a> example:
&quot;&lt;your-rails-app&gt;/test/fixtures/web_sites.yml&quot;). The format
of a YAML fixture file looks like this:
</p>
<pre>
  rubyonrails:
    id: 1
    name: Ruby on Rails
    url: http://www.rubyonrails.org

  google:
    id: 2
    name: Google
    url: http://www.google.com
</pre>
<p>
This YAML fixture file includes two fixtures. Each YAML fixture (ie.
record) is given a name and is followed by an indented list of key/value
pairs in the &quot;key: value&quot; format. Records are separated by a
blank line for your viewing pleasure.
</p>
<p>
Note that YAML fixtures are unordered. If you want ordered fixtures, use
the omap YAML type. See <a
href="http://yaml.org/type/omap.html">yaml.org/type/omap.html</a> for the
specification. You will need ordered fixtures when you have foreign key
constraints on keys in the same table. This is commonly needed for tree
structures. Example:
</p>
<pre>
   --- !omap
   - parent:
       id:         1
       parent_id:  NULL
       title:      Parent
   - child:
       id:         2
       parent_id:  1
       title:      Child
</pre>
<h1>CSV fixtures</h1>
<p>
<a href="Fixtures.html">Fixtures</a> can also be kept in the Comma
Separated Value format. Akin to YAML fixtures, CSV fixtures are stored in a
single file, but instead end with the .csv file extension (<a
href="Rails.html">Rails</a> example:
&quot;&lt;your-rails-app&gt;/test/fixtures/web_sites.csv&quot;)
</p>
<p>
The format of this type of fixture file is much more compact than the
others, but also a little harder to read by us humans. The first line of
the CSV file is a comma-separated list of field names. The rest of the file
is then comprised of the actual data (1 per line). Here&#8216;s an example:
</p>
<pre>
  id, name, url
  1, Ruby On Rails, http://www.rubyonrails.org
  2, Google, http://www.google.com
</pre>
<p>
Should you have a piece of data with a comma character in it, you can place
double quotes around that value. If you need to use a double quote
character, you must escape it with another double quote.
</p>
<p>
Another unique attribute of the CSV fixture is that it has <b>no</b>
fixture name like the other two formats. Instead, the fixture names are
automatically generated by deriving the class name of the fixture file and
adding an incrementing number to the end. In our example, the 1st fixture
would be called &quot;web_site_1&quot; and the 2nd one would be called
&quot;web_site_2&quot;.
</p>
<p>
Most databases and spreadsheets support exporting to CSV format, so this is
a great format for you to choose if you have existing data somewhere
already.
</p>
<h1>Single-file fixtures</h1>
<p>
This type of fixture was the original format for Active Record that has
since been deprecated in favor of the YAML and CSV formats. <a
href="Fixtures.html">Fixtures</a> for this format are created by placing
text files in a sub-directory (with the name of the model) to the directory
appointed by <tt>ActiveSupport::TestCase.fixture_path=(path)</tt> (this is
automatically configured for <a href="Rails.html">Rails</a>, so you can
just put your files in
&lt;your-rails-app&gt;/test/fixtures/&lt;your-model-name&gt;/ &#8212; like
&lt;your-rails-app&gt;/test/fixtures/web_sites/ for the WebSite model).
</p>
<p>
Each text file placed in this directory represents a &quot;record&quot;.
Usually these types of fixtures are named without extensions, but if you
are on a Windows machine, you might consider adding .txt as the extension.
Here&#8216;s what the above example might look like:
</p>
<pre>
  web_sites/google
  web_sites/yahoo.txt
  web_sites/ruby-on-rails
</pre>
<p>
The file format of a standard fixture is simple. Each line is a property
(or column in db speak) and has the syntax of &quot;name =&gt; value&quot;.
Here&#8216;s an example of the ruby-on-rails fixture above:
</p>
<pre>
  id =&gt; 1
  name =&gt; Ruby on Rails
  url =&gt; http://www.rubyonrails.org
</pre>
<h1>Using <a href="Fixtures.html">Fixtures</a></h1>
<p>
Since fixtures are a testing construct, we use them in our unit and
functional tests. There are two ways to use the fixtures, but first
let&#8216;s take a look at a sample unit test:
</p>
<pre>
  require 'web_site'

  class WebSiteTest &lt; ActiveSupport::TestCase
    def test_web_site_count
      assert_equal 2, WebSite.count
    end
  end
</pre>
<p>
As it stands, unless we pre-load the web_site table in our database with
two records, this test will fail. Here&#8216;s the easiest way to add
fixtures to the database:
</p>
<pre>
  ...
  class WebSiteTest &lt; ActiveSupport::TestCase
    fixtures :web_sites # add more by separating the symbols with commas
  ...
</pre>
<p>
By adding a &quot;fixtures&quot; method to the test case and passing it a
list of symbols (only one is shown here though), we trigger the testing
environment to automatically load the appropriate fixtures into the
database before each test. To ensure consistent data, the environment
deletes the fixtures before running the load.
</p>
<p>
In addition to being available in the database, the fixtures are also
loaded into a hash stored in an instance variable of the test case. It is
named after the symbol&#8230; so, in our example, there would be a hash
available called @web_sites. This is where the &quot;fixture name&quot;
comes into play.
</p>
<p>
On top of that, each record is automatically &quot;found&quot; (using
Model.find(id)) and placed in the instance variable of its name. So for the
YAML fixtures, we&#8216;d get @rubyonrails and @google, which could be
interrogated using regular Active Record semantics:
</p>
<pre>
  # test if the object created from the fixture data has the same attributes as the data itself
  def test_find
    assert_equal @web_sites[&quot;rubyonrails&quot;][&quot;name&quot;], @rubyonrails.name
  end
</pre>
<p>
As seen above, the data hash created from the YAML fixtures would have
@web_sites[&quot;rubyonrails&quot;][&quot;url&quot;] return &quot;<a
href="http://www.rubyonrails.org">www.rubyonrails.org</a>&quot; and
@web_sites[&quot;google&quot;][&quot;name&quot;] would return
&quot;Google&quot;. The same fixtures, but loaded from a CSV fixture file,
would be accessible via
@web_sites[&quot;web_site_1&quot;][&quot;name&quot;] == &quot;Ruby on <a
href="Rails.html">Rails</a>&quot; and have the individual fixtures
available as instance variables @web_site_1 and @web_site_2.
</p>
<p>
If you do not wish to use instantiated fixtures (usually for performance
reasons) there are two options.
</p>
<pre>
  - to completely disable instantiated fixtures:
      self.use_instantiated_fixtures = false

  - to keep the fixture instance (@web_sites) available, but do not automatically 'find' each instance:
      self.use_instantiated_fixtures = :no_instances
</pre>
<p>
Even if auto-instantiated fixtures are disabled, you can still access them
by name via special dynamic methods. Each method has the same name as the
model, and accepts the name of the fixture to instantiate:
</p>
<pre>
  fixtures :web_sites

  def test_find
    assert_equal &quot;Ruby on Rails&quot;, web_sites(:rubyonrails).name
  end
</pre>
<h1>Dynamic fixtures with ERb</h1>
<p>
Some times you don&#8216;t care about the content of the fixtures as much
as you care about the volume. In these cases, you can mix ERb in with your
YAML or CSV fixtures to create a bunch of fixtures for load testing, like:
</p>
<p>
&lt;% for i in 1..1000 %&gt; fix_&lt;%= i %&gt;:
</p>
<pre>
  id: &lt;%= i %&gt;
  name: guy_&lt;%= 1 %&gt;
</pre>
<p>
&lt;% end %&gt;
</p>
<p>
This will create 1000 very simple YAML fixtures.
</p>
<p>
Using ERb, you can also inject dynamic values into your fixtures with
inserts like &lt;%= Date.today.strftime(&quot;%Y-%m-%d&quot;) %&gt;. This
is however a feature to be used with some caution. The point of fixtures
are that they&#8216;re stable units of predictable sample data. If you feel
that you need to inject dynamic values, then perhaps you should reexamine
whether your application is properly testable. Hence, dynamic values in
fixtures are to be considered a code smell.
</p>
<h1>Transactional fixtures</h1>
<p>
TestCases can use begin+rollback to isolate their changes to the database
instead of having to delete+insert for every test case. They can also turn
off auto-instantiation of fixture data since the feature is costly and
often unused.
</p>
<pre>
  class FooTest &lt; ActiveSupport::TestCase
    self.use_transactional_fixtures = true
    self.use_instantiated_fixtures = false

    fixtures :foos

    def test_godzilla
      assert !Foo.find(:all).empty?
      Foo.destroy_all
      assert Foo.find(:all).empty?
    end

    def test_godzilla_aftermath
      assert !Foo.find(:all).empty?
    end
  end
</pre>
<p>
If you preload your test database with all fixture data (probably in the
Rakefile task) and use transactional fixtures, then you may omit all
fixtures declarations in your test cases since all the data&#8216;s already
there and every case rolls back its changes.
</p>
<p>
In order to use instantiated fixtures with preloaded data, set
+self.pre_loaded_fixtures+ to true. This will provide access to fixture
data for every table that has been loaded through fixtures (depending on
the value of <tt>use_instantiated_fixtures</tt>)
</p>
<p>
When <b>not</b> to use transactional fixtures:
</p>
<pre>
  1. You're testing whether a transaction works correctly. Nested transactions don't commit until all parent transactions commit,
     particularly, the fixtures transaction which is begun in setup and rolled back in teardown. Thus, you won't be able to verify
     the results of your transaction until Active Record supports nested transactions or savepoints (in progress).
  2. Your database does not support transactions. Every Active Record database supports transactions except MySQL MyISAM.
     Use InnoDB, MaxDB, or NDB instead.
</pre>
<h1>Advanced YAML <a href="Fixtures.html">Fixtures</a></h1>
<p>
YAML fixtures that don&#8216;t specify an ID get some extra features:
</p>
<ul>
<li>Stable, autogenerated ID&#8216;s

</li>
<li>Label references for associations (belongs_to, has_one, has_many)

</li>
<li>HABTM associations as inline lists

</li>
<li>Autofilled timestamp columns

</li>
<li>Fixture label interpolation

</li>
<li>Support for YAML defaults

</li>
</ul>
<h2>Stable, autogenerated ID&#8216;s</h2>
<p>
Here, have a monkey fixture:
</p>
<pre>
  george:
    id: 1
    name: George the Monkey

  reginald:
    id: 2
    name: Reginald the Pirate
</pre>
<p>
Each of these fixtures has two unique identifiers: one for the database and
one for the humans. Why don&#8216;t we generate the primary key instead?
Hashing each fixture&#8216;s label yields a consistent ID:
</p>
<pre>
  george: # generated id: 503576764
    name: George the Monkey

  reginald: # generated id: 324201669
    name: Reginald the Pirate
</pre>
<p>
ActiveRecord looks at the fixture&#8216;s model class, discovers the
correct primary key, and generates it right before inserting the fixture
into the database.
</p>
<p>
The generated ID for a given label is constant, so we can discover any
fixture&#8216;s ID without loading anything, as long as we know the label.
</p>
<h2>Label references for associations (belongs_to, has_one, has_many)</h2>
<p>
Specifying foreign keys in fixtures can be very fragile, not to mention
difficult to read. Since ActiveRecord can figure out the ID of any fixture
from its label, you can specify FK&#8216;s by label instead of ID.
</p>
<h3>belongs_to</h3>
<p>
Let&#8216;s break out some more monkeys and pirates.
</p>
<pre>
  ### in pirates.yml

  reginald:
    id: 1
    name: Reginald the Pirate
    monkey_id: 1

  ### in monkeys.yml

  george:
    id: 1
    name: George the Monkey
    pirate_id: 1
</pre>
<p>
Add a few more monkeys and pirates and break this into multiple files, and
it gets pretty hard to keep track of what&#8216;s going on. Let&#8216;s use
labels instead of ID&#8216;s:
</p>
<pre>
  ### in pirates.yml

  reginald:
    name: Reginald the Pirate
    monkey: george

  ### in monkeys.yml

  george:
    name: George the Monkey
    pirate: reginald
</pre>
<p>
Pow! All is made clear. ActiveRecord reflects on the fixture&#8216;s model
class, finds all the <tt>belongs_to</tt> associations, and allows you to
specify a target <b>label</b> for the <b>association</b> (monkey: george)
rather than a target <b>id</b> for the <b>FK</b> (monkey_id: 1).
</p>
<h4>Polymorphic belongs_to</h4>
<p>
Supporting polymorphic relationships is a little bit more complicated,
since ActiveRecord needs to know what type your association is pointing at.
Something like this should look familiar:
</p>
<pre>
  ### in fruit.rb

  belongs_to :eater, :polymorphic =&gt; true

  ### in fruits.yml

  apple:
    id: 1
    name: apple
    eater_id: 1
    eater_type: Monkey
</pre>
<p>
Can we do better? You bet!
</p>
<pre>
  apple:
    eater: george (Monkey)
</pre>
<p>
Just provide the polymorphic target type and ActiveRecord will take care of
the rest.
</p>
<h3>has_and_belongs_to_many</h3>
<p>
Time to give our monkey some fruit.
</p>
<pre>
  ### in monkeys.yml

  george:
    id: 1
    name: George the Monkey
    pirate_id: 1

  ### in fruits.yml

  apple:
    id: 1
    name: apple

  orange:
    id: 2
    name: orange

  grape:
    id: 3
    name: grape

  ### in fruits_monkeys.yml

  apple_george:
    fruit_id: 1
    monkey_id: 1

  orange_george:
    fruit_id: 2
    monkey_id: 1

  grape_george:
    fruit_id: 3
    monkey_id: 1
</pre>
<p>
Let&#8216;s make the HABTM fixture go away.
</p>
<pre>
  ### in monkeys.yml

  george:
    name: George the Monkey
    pirate: reginald
    fruits: apple, orange, grape

  ### in fruits.yml

  apple:
    name: apple

  orange:
    name: orange

  grape:
    name: grape
</pre>
<p>
Zap! No more fruits_monkeys.yml file. We&#8216;ve specified the list of
fruits on George&#8216;s fixture, but we could&#8216;ve just as easily
specified a list of monkeys on each fruit. As with <tt>belongs_to</tt>,
ActiveRecord reflects on the fixture&#8216;s model class and discovers the
<tt>has_and_belongs_to_many</tt> associations.
</p>
<h2>Autofilled timestamp columns</h2>
<p>
If your table/model specifies any of ActiveRecord&#8216;s standard
timestamp columns (created_at, created_on, updated_at, updated_on), they
will automatically be set to Time.now.
</p>
<p>
If you&#8216;ve set specific values, they&#8216;ll be left alone.
</p>
<h2>Fixture label interpolation</h2>
<p>
The label of the current fixture is always available as a column value:
</p>
<pre>
  geeksomnia:
    name: Geeksomnia's Account
    subdomain: $LABEL
</pre>
<p>
Also, sometimes (like when porting older join table fixtures) you&#8216;ll
need to be able to get ahold of the identifier for a given label. <a
href="ERB.html">ERB</a> to the rescue:
</p>
<pre>
  george_reginald:
    monkey_id: &lt;%= Fixtures.identify(:reginald) %&gt;
    pirate_id: &lt;%= Fixtures.identify(:george) %&gt;
</pre>
<h2>Support for YAML defaults</h2>
<p>
You probably already know how to use YAML to set and reuse defaults in your
+database.yml+ file,. You can use the same technique in your fixtures:
</p>
<pre>
  DEFAULTS: &amp;DEFAULTS
    created_on: &lt;%= 3.weeks.ago.to_s(:db) %&gt;

  first:
    name: Smurf
    &lt;&lt;: *DEFAULTS

  second:
    name: Fraggle
    &lt;&lt;: *DEFAULTS
</pre>
<p>
Any fixture labeled &quot;DEFAULTS&quot; is safely ignored.
</p>
</div>




<p></p>


<h1>Constants</h1><p><table><tr><th>Name</th><th>Value</th></tr>
<tr>
<td class="highlight">DEFAULT_FILTER_RE</td>

<td class="normal">/\.ya?ml$/</td>



</tr>
</table></p>


<h1>Attributes</h1><p><table><tr><th>Name</th><th>Read/write?</th></tr>
<tr>
<td class="highlight">table_name</td>




<td class="normal">R</td>
</tr>
</table></p>


<h1>Public Class Methods</h1>


<a class="small" name="M000189"><br/></a>
<div class="method_block"><h3>
<a href='#M000189'>


cache_fixtures

(connection, fixtures)

</a>
</h3>

<p class="source_link" id="M000189-show-link"><a onclick="toggle('M000189-source'); toggleText('M000189-link'); return false;" href="#" id="M000189-link">Show source...</a></p><div class="source" id="M000189-source"><pre>     <span class="ruby-comment cmt"># File vendor/rails/activerecord/lib/active_record/fixtures.rb, line 472</span>
472:   <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">cache_fixtures</span>(<span class="ruby-identifier">connection</span>, <span class="ruby-identifier">fixtures</span>)
473:     <span class="ruby-identifier">cache_for_connection</span>(<span class="ruby-identifier">connection</span>).<span class="ruby-identifier">update</span>(<span class="ruby-identifier">fixtures</span>.<span class="ruby-identifier">index_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span> <span class="ruby-identifier">f</span>.<span class="ruby-identifier">table_name</span> })
474:   <span class="ruby-keyword kw">end</span></pre></div>
</div>

<a class="small" name="M000186"><br/></a>
<div class="method_block"><h3>
<a href='#M000186'>


cache_for_connection

(connection)

</a>
</h3>

<p class="source_link" id="M000186-show-link"><a onclick="toggle('M000186-source'); toggleText('M000186-link'); return false;" href="#" id="M000186-link">Show source...</a></p><div class="source" id="M000186-source"><pre>     <span class="ruby-comment cmt"># File vendor/rails/activerecord/lib/active_record/fixtures.rb, line 454</span>
454:   <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">cache_for_connection</span>(<span class="ruby-identifier">connection</span>)
455:     <span class="ruby-ivar">@@all_cached_fixtures</span>[<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">object_id</span>] <span class="ruby-operator">||=</span> {}
456:     <span class="ruby-ivar">@@all_cached_fixtures</span>[<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">object_id</span>]
457:   <span class="ruby-keyword kw">end</span></pre></div>
</div>

<a class="small" name="M000188"><br/></a>
<div class="method_block"><h3>
<a href='#M000188'>


cached_fixtures

(connection, keys_to_fetch = nil)

</a>
</h3>

<p class="source_link" id="M000188-show-link"><a onclick="toggle('M000188-source'); toggleText('M000188-link'); return false;" href="#" id="M000188-link">Show source...</a></p><div class="source" id="M000188-source"><pre>     <span class="ruby-comment cmt"># File vendor/rails/activerecord/lib/active_record/fixtures.rb, line 463</span>
463:   <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">cached_fixtures</span>(<span class="ruby-identifier">connection</span>, <span class="ruby-identifier">keys_to_fetch</span> = <span class="ruby-keyword kw">nil</span>)
464:     <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">keys_to_fetch</span>
465:       <span class="ruby-identifier">fixtures</span> = <span class="ruby-identifier">cache_for_connection</span>(<span class="ruby-identifier">connection</span>).<span class="ruby-identifier">values_at</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">keys_to_fetch</span>)
466:     <span class="ruby-keyword kw">else</span>
467:       <span class="ruby-identifier">fixtures</span> = <span class="ruby-identifier">cache_for_connection</span>(<span class="ruby-identifier">connection</span>).<span class="ruby-identifier">values</span>
468:     <span class="ruby-keyword kw">end</span>
469:     <span class="ruby-identifier">fixtures</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">fixtures</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">fixtures</span>.<span class="ruby-identifier">first</span>
470:   <span class="ruby-keyword kw">end</span></pre></div>
</div>

<a class="small" name="M000192"><br/></a>
<div class="method_block"><h3>
<a href='#M000192'>


create_fixtures

(fixtures_directory, table_names, class_names = {}) {|: ActiveRecord::Base.connection| ...}

</a>
</h3>

<p class="source_link" id="M000192-show-link"><a onclick="toggle('M000192-source'); toggleText('M000192-link'); return false;" href="#" id="M000192-link">Show source...</a></p><div class="source" id="M000192-source"><pre>     <span class="ruby-comment cmt"># File vendor/rails/activerecord/lib/active_record/fixtures.rb, line 500</span>
500:   <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">create_fixtures</span>(<span class="ruby-identifier">fixtures_directory</span>, <span class="ruby-identifier">table_names</span>, <span class="ruby-identifier">class_names</span> = {})
501:     <span class="ruby-identifier">table_names</span> = [<span class="ruby-identifier">table_names</span>].<span class="ruby-identifier">flatten</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">n</span>.<span class="ruby-identifier">to_s</span> }
502:     <span class="ruby-identifier">connection</span>  = <span class="ruby-identifier">block_given?</span> <span class="ruby-value">? </span><span class="ruby-keyword kw">yield</span> <span class="ruby-operator">:</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">connection</span>
503: 
504:     <span class="ruby-identifier">table_names_to_fetch</span> = <span class="ruby-identifier">table_names</span>.<span class="ruby-identifier">reject</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">table_name</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fixture_is_cached?</span>(<span class="ruby-identifier">connection</span>, <span class="ruby-identifier">table_name</span>) }
505: 
506:     <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">table_names_to_fetch</span>.<span class="ruby-identifier">empty?</span>
507:       <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">silence</span> <span class="ruby-keyword kw">do</span>
508:         <span class="ruby-identifier">connection</span>.<span class="ruby-identifier">disable_referential_integrity</span> <span class="ruby-keyword kw">do</span>
509:           <span class="ruby-identifier">fixtures_map</span> = {}
510: 
511:           <span class="ruby-identifier">fixtures</span> = <span class="ruby-identifier">table_names_to_fetch</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">table_name</span><span class="ruby-operator">|</span>
512:             <span class="ruby-identifier">fixtures_map</span>[<span class="ruby-identifier">table_name</span>] = <span class="ruby-constant">Fixtures</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">connection</span>, <span class="ruby-constant">File</span>.<span class="ruby-identifier">split</span>(<span class="ruby-identifier">table_name</span>.<span class="ruby-identifier">to_s</span>).<span class="ruby-identifier">last</span>, <span class="ruby-identifier">class_names</span>[<span class="ruby-identifier">table_name</span>.<span class="ruby-identifier">to_sym</span>], <span class="ruby-constant">File</span>.<span class="ruby-identifier">join</span>(<span class="ruby-identifier">fixtures_directory</span>, <span class="ruby-identifier">table_name</span>.<span class="ruby-identifier">to_s</span>))
513:           <span class="ruby-keyword kw">end</span>
514: 
515:           <span class="ruby-identifier">all_loaded_fixtures</span>.<span class="ruby-identifier">update</span>(<span class="ruby-identifier">fixtures_map</span>)
516: 
517:           <span class="ruby-identifier">connection</span>.<span class="ruby-identifier">transaction</span>(<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[<span class="ruby-value str">'open_transactions'</span>].<span class="ruby-identifier">to_i</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>) <span class="ruby-keyword kw">do</span>
518:             <span class="ruby-identifier">fixtures</span>.<span class="ruby-identifier">reverse</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">fixture</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fixture</span>.<span class="ruby-identifier">delete_existing_fixtures</span> }
519:             <span class="ruby-identifier">fixtures</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">fixture</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fixture</span>.<span class="ruby-identifier">insert_fixtures</span> }
520: 
521:             <span class="ruby-comment cmt"># Cap primary key sequences to max(pk).</span>
522:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">connection</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">:reset_pk_sequence!</span>)
523:               <span class="ruby-identifier">table_names</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">table_name</span><span class="ruby-operator">|</span>
524:                 <span class="ruby-identifier">connection</span>.<span class="ruby-identifier">reset_pk_sequence!</span>(<span class="ruby-identifier">table_name</span>)
525:               <span class="ruby-keyword kw">end</span>
526:             <span class="ruby-keyword kw">end</span>
527:           <span class="ruby-keyword kw">end</span>
528: 
529:           <span class="ruby-identifier">cache_fixtures</span>(<span class="ruby-identifier">connection</span>, <span class="ruby-identifier">fixtures</span>)
530:         <span class="ruby-keyword kw">end</span>
531:       <span class="ruby-keyword kw">end</span>
532:     <span class="ruby-keyword kw">end</span>
533:     <span class="ruby-identifier">cached_fixtures</span>(<span class="ruby-identifier">connection</span>, <span class="ruby-identifier">table_names</span>)
534:   <span class="ruby-keyword kw">end</span></pre></div>
</div>

<a class="small" name="M000187"><br/></a>
<div class="method_block"><h3>
<a href='#M000187'>


fixture_is_cached?

(connection, table_name)

</a>
</h3>

<p class="source_link" id="M000187-show-link"><a onclick="toggle('M000187-source'); toggleText('M000187-link'); return false;" href="#" id="M000187-link">Show source...</a></p><div class="source" id="M000187-source"><pre>     <span class="ruby-comment cmt"># File vendor/rails/activerecord/lib/active_record/fixtures.rb, line 459</span>
459:   <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">fixture_is_cached?</span>(<span class="ruby-identifier">connection</span>, <span class="ruby-identifier">table_name</span>)
460:     <span class="ruby-identifier">cache_for_connection</span>(<span class="ruby-identifier">connection</span>)[<span class="ruby-identifier">table_name</span>]
461:   <span class="ruby-keyword kw">end</span></pre></div>
</div>

<a class="small" name="M000193"><br/></a>
<div class="method_block"><h3>
<a href='#M000193'>


identify

(label)

</a>
</h3>
<p>
Returns a consistent identifier for <tt>label</tt>. This will always be a
positive integer, and will always be the same for a given label, assuming
the same OS, platform, and version of Ruby.
</p>

<p class="source_link" id="M000193-show-link"><a onclick="toggle('M000193-source'); toggleText('M000193-link'); return false;" href="#" id="M000193-link">Show source...</a></p><div class="source" id="M000193-source"><pre>     <span class="ruby-comment cmt"># File vendor/rails/activerecord/lib/active_record/fixtures.rb, line 539</span>
539:   <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">identify</span>(<span class="ruby-identifier">label</span>)
540:     <span class="ruby-identifier">label</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">hash</span>.<span class="ruby-identifier">abs</span>
541:   <span class="ruby-keyword kw">end</span></pre></div>
</div>

<a class="small" name="M000191"><br/></a>
<div class="method_block"><h3>
<a href='#M000191'>


instantiate_all_loaded_fixtures

(object, load_instances = true)

</a>
</h3>

<p class="source_link" id="M000191-show-link"><a onclick="toggle('M000191-source'); toggleText('M000191-link'); return false;" href="#" id="M000191-link">Show source...</a></p><div class="source" id="M000191-source"><pre>     <span class="ruby-comment cmt"># File vendor/rails/activerecord/lib/active_record/fixtures.rb, line 491</span>
491:   <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">instantiate_all_loaded_fixtures</span>(<span class="ruby-identifier">object</span>, <span class="ruby-identifier">load_instances</span> = <span class="ruby-keyword kw">true</span>)
492:     <span class="ruby-identifier">all_loaded_fixtures</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">table_name</span>, <span class="ruby-identifier">fixtures</span><span class="ruby-operator">|</span>
493:       <span class="ruby-constant">Fixtures</span>.<span class="ruby-identifier">instantiate_fixtures</span>(<span class="ruby-identifier">object</span>, <span class="ruby-identifier">table_name</span>, <span class="ruby-identifier">fixtures</span>, <span class="ruby-identifier">load_instances</span>)
494:     <span class="ruby-keyword kw">end</span>
495:   <span class="ruby-keyword kw">end</span></pre></div>
</div>

<a class="small" name="M000190"><br/></a>
<div class="method_block"><h3>
<a href='#M000190'>


instantiate_fixtures

(object, table_name, fixtures, load_instances = true)

</a>
</h3>

<p class="source_link" id="M000190-show-link"><a onclick="toggle('M000190-source'); toggleText('M000190-link'); return false;" href="#" id="M000190-link">Show source...</a></p><div class="source" id="M000190-source"><pre>     <span class="ruby-comment cmt"># File vendor/rails/activerecord/lib/active_record/fixtures.rb, line 476</span>
476:   <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">instantiate_fixtures</span>(<span class="ruby-identifier">object</span>, <span class="ruby-identifier">table_name</span>, <span class="ruby-identifier">fixtures</span>, <span class="ruby-identifier">load_instances</span> = <span class="ruby-keyword kw">true</span>)
477:     <span class="ruby-identifier">object</span>.<span class="ruby-identifier">instance_variable_set</span> <span class="ruby-node">&quot;@#{table_name.to_s.gsub('.','_')}&quot;</span>, <span class="ruby-identifier">fixtures</span>
478:     <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">load_instances</span>
479:       <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">silence</span> <span class="ruby-keyword kw">do</span>
480:         <span class="ruby-identifier">fixtures</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">name</span>, <span class="ruby-identifier">fixture</span><span class="ruby-operator">|</span>
481:           <span class="ruby-keyword kw">begin</span>
482:             <span class="ruby-identifier">object</span>.<span class="ruby-identifier">instance_variable_set</span> <span class="ruby-node">&quot;@#{name}&quot;</span>, <span class="ruby-identifier">fixture</span>.<span class="ruby-identifier">find</span>
483:           <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">FixtureClassNotFound</span>
484:             <span class="ruby-keyword kw">nil</span>
485:           <span class="ruby-keyword kw">end</span>
486:         <span class="ruby-keyword kw">end</span>
487:       <span class="ruby-keyword kw">end</span>
488:     <span class="ruby-keyword kw">end</span>
489:   <span class="ruby-keyword kw">end</span></pre></div>
</div>

<a class="small" name="M000194"><br/></a>
<div class="method_block"><h3>
<a href='#M000194'>


new

(connection, table_name, class_name, fixture_path, file_filter = DEFAULT_FILTER_RE)

</a>
</h3>

<p class="source_link" id="M000194-show-link"><a onclick="toggle('M000194-source'); toggleText('M000194-link'); return false;" href="#" id="M000194-link">Show source...</a></p><div class="source" id="M000194-source"><pre>     <span class="ruby-comment cmt"># File vendor/rails/activerecord/lib/active_record/fixtures.rb, line 545</span>
545:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">connection</span>, <span class="ruby-identifier">table_name</span>, <span class="ruby-identifier">class_name</span>, <span class="ruby-identifier">fixture_path</span>, <span class="ruby-identifier">file_filter</span> = <span class="ruby-constant">DEFAULT_FILTER_RE</span>)
546:     <span class="ruby-ivar">@connection</span>, <span class="ruby-ivar">@table_name</span>, <span class="ruby-ivar">@fixture_path</span>, <span class="ruby-ivar">@file_filter</span> = <span class="ruby-identifier">connection</span>, <span class="ruby-identifier">table_name</span>, <span class="ruby-identifier">fixture_path</span>, <span class="ruby-identifier">file_filter</span>
547:     <span class="ruby-ivar">@class_name</span> = <span class="ruby-identifier">class_name</span> <span class="ruby-operator">||</span>
548:                   (<span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">pluralize_table_names</span> <span class="ruby-value">? </span><span class="ruby-ivar">@table_name</span>.<span class="ruby-identifier">singularize</span>.<span class="ruby-identifier">camelize</span> <span class="ruby-operator">:</span> <span class="ruby-ivar">@table_name</span>.<span class="ruby-identifier">camelize</span>)
549:     <span class="ruby-ivar">@table_name</span> = <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">table_name_prefix</span> <span class="ruby-operator">+</span> <span class="ruby-ivar">@table_name</span> <span class="ruby-operator">+</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">table_name_suffix</span>
550:     <span class="ruby-ivar">@table_name</span> = <span class="ruby-identifier">class_name</span>.<span class="ruby-identifier">table_name</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">class_name</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">:table_name</span>)
551:     <span class="ruby-ivar">@connection</span> = <span class="ruby-identifier">class_name</span>.<span class="ruby-identifier">connection</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">class_name</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">:connection</span>)
552:     <span class="ruby-identifier">read_fixture_files</span>
553:   <span class="ruby-keyword kw">end</span></pre></div>
</div>

<a class="small" name="M000185"><br/></a>
<div class="method_block"><h3>
<a href='#M000185'>


reset_cache

(connection = nil)

</a>
</h3>

<p class="source_link" id="M000185-show-link"><a onclick="toggle('M000185-source'); toggleText('M000185-link'); return false;" href="#" id="M000185-link">Show source...</a></p><div class="source" id="M000185-source"><pre>     <span class="ruby-comment cmt"># File vendor/rails/activerecord/lib/active_record/fixtures.rb, line 449</span>
449:   <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">reset_cache</span>(<span class="ruby-identifier">connection</span> = <span class="ruby-keyword kw">nil</span>)
450:     <span class="ruby-identifier">connection</span> <span class="ruby-operator">||=</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">connection</span>
451:     <span class="ruby-ivar">@@all_cached_fixtures</span>[<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">object_id</span>] = {}
452:   <span class="ruby-keyword kw">end</span></pre></div>
</div>


<h1>Public Instance Methods</h1>


<a class="small" name="M000195"><br/></a>
<div class="method_block"><h3>
<a href='#M000195'>


delete_existing_fixtures

()

</a>
</h3>

<p class="source_link" id="M000195-show-link"><a onclick="toggle('M000195-source'); toggleText('M000195-link'); return false;" href="#" id="M000195-link">Show source...</a></p><div class="source" id="M000195-source"><pre>     <span class="ruby-comment cmt"># File vendor/rails/activerecord/lib/active_record/fixtures.rb, line 555</span>
555:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">delete_existing_fixtures</span>
556:     <span class="ruby-ivar">@connection</span>.<span class="ruby-identifier">delete</span> <span class="ruby-node">&quot;DELETE FROM #{@connection.quote_table_name(table_name)}&quot;</span>, <span class="ruby-value str">'Fixture Delete'</span>
557:   <span class="ruby-keyword kw">end</span></pre></div>
</div>

<a class="small" name="M000196"><br/></a>
<div class="method_block"><h3>
<a href='#M000196'>


insert_fixtures

()

</a>
</h3>

<p class="source_link" id="M000196-show-link"><a onclick="toggle('M000196-source'); toggleText('M000196-link'); return false;" href="#" id="M000196-link">Show source...</a></p><div class="source" id="M000196-source"><pre>     <span class="ruby-comment cmt"># File vendor/rails/activerecord/lib/active_record/fixtures.rb, line 559</span>
559:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">insert_fixtures</span>
560:     <span class="ruby-identifier">now</span> = <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">default_timezone</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">:utc</span> <span class="ruby-operator">?</span> <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>.<span class="ruby-identifier">utc</span> <span class="ruby-operator">:</span> <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
561:     <span class="ruby-identifier">now</span> = <span class="ruby-identifier">now</span>.<span class="ruby-identifier">to_s</span>(<span class="ruby-identifier">:db</span>)
562: 
563:     <span class="ruby-comment cmt"># allow a standard key to be used for doing defaults in YAML</span>
564:     <span class="ruby-identifier">delete</span>(<span class="ruby-identifier">assoc</span>(<span class="ruby-value str">&quot;DEFAULTS&quot;</span>))
565: 
566:     <span class="ruby-comment cmt"># track any join tables we need to insert later</span>
567:     <span class="ruby-identifier">habtm_fixtures</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">h</span>, <span class="ruby-identifier">habtm</span><span class="ruby-operator">|</span>
568:       <span class="ruby-identifier">h</span>[<span class="ruby-identifier">habtm</span>] = <span class="ruby-constant">HabtmFixtures</span>.<span class="ruby-identifier">new</span>(<span class="ruby-ivar">@connection</span>, <span class="ruby-identifier">habtm</span>.<span class="ruby-identifier">options</span>[<span class="ruby-identifier">:join_table</span>], <span class="ruby-keyword kw">nil</span>, <span class="ruby-keyword kw">nil</span>)
569:     <span class="ruby-keyword kw">end</span>
570: 
571:     <span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">label</span>, <span class="ruby-identifier">fixture</span><span class="ruby-operator">|</span>
572:       <span class="ruby-identifier">row</span> = <span class="ruby-identifier">fixture</span>.<span class="ruby-identifier">to_hash</span>
573: 
574:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">model_class</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">model_class</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
575:         <span class="ruby-comment cmt"># fill in timestamp columns if they aren't specified and the model is set to record_timestamps</span>
576:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">model_class</span>.<span class="ruby-identifier">record_timestamps</span>
577:           <span class="ruby-identifier">timestamp_column_names</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">name</span><span class="ruby-operator">|</span>
578:             <span class="ruby-identifier">row</span>[<span class="ruby-identifier">name</span>] = <span class="ruby-identifier">now</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">row</span>.<span class="ruby-identifier">key?</span>(<span class="ruby-identifier">name</span>)
579:           <span class="ruby-keyword kw">end</span>
580:         <span class="ruby-keyword kw">end</span>
581: 
582:         <span class="ruby-comment cmt"># interpolate the fixture label</span>
583:         <span class="ruby-identifier">row</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span>
584:           <span class="ruby-identifier">row</span>[<span class="ruby-identifier">key</span>] = <span class="ruby-identifier">label</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;$LABEL&quot;</span>
585:         <span class="ruby-keyword kw">end</span>
586: 
587:         <span class="ruby-comment cmt"># generate a primary key if necessary</span>
588:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">has_primary_key_column?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">row</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">primary_key_name</span>)
589:           <span class="ruby-identifier">row</span>[<span class="ruby-identifier">primary_key_name</span>] = <span class="ruby-constant">Fixtures</span>.<span class="ruby-identifier">identify</span>(<span class="ruby-identifier">label</span>)
590:         <span class="ruby-keyword kw">end</span>
591: 
592:         <span class="ruby-comment cmt"># If STI is used, find the correct subclass for association reflection</span>
593:         <span class="ruby-identifier">reflection_class</span> =
594:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">row</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">inheritance_column_name</span>)
595:             <span class="ruby-identifier">row</span>[<span class="ruby-identifier">inheritance_column_name</span>].<span class="ruby-identifier">constantize</span> <span class="ruby-keyword kw">rescue</span> <span class="ruby-identifier">model_class</span>
596:           <span class="ruby-keyword kw">else</span>
597:             <span class="ruby-identifier">model_class</span>
598:           <span class="ruby-keyword kw">end</span>
599: 
600:         <span class="ruby-identifier">reflection_class</span>.<span class="ruby-identifier">reflect_on_all_associations</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">association</span><span class="ruby-operator">|</span>
601:           <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">association</span>.<span class="ruby-identifier">macro</span>
602:           <span class="ruby-keyword kw">when</span> <span class="ruby-identifier">:belongs_to</span>
603:             <span class="ruby-comment cmt"># Do not replace association name with association foreign key if they are named the same</span>
604:             <span class="ruby-identifier">fk_name</span> = (<span class="ruby-identifier">association</span>.<span class="ruby-identifier">options</span>[<span class="ruby-identifier">:foreign_key</span>] <span class="ruby-operator">||</span> <span class="ruby-node">&quot;#{association.name}_id&quot;</span>).<span class="ruby-identifier">to_s</span>
605: 
606:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">association</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">fk_name</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">value</span> = <span class="ruby-identifier">row</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">association</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">to_s</span>)
607:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">association</span>.<span class="ruby-identifier">options</span>[<span class="ruby-identifier">:polymorphic</span>]
608:                 <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/\s*\(([^\)]*)\)\s*$/</span>, <span class="ruby-value str">&quot;&quot;</span>)
609:                   <span class="ruby-identifier">target_type</span> = <span class="ruby-identifier">$1</span>
610:                   <span class="ruby-identifier">target_type_name</span> = (<span class="ruby-identifier">association</span>.<span class="ruby-identifier">options</span>[<span class="ruby-identifier">:foreign_type</span>] <span class="ruby-operator">||</span> <span class="ruby-node">&quot;#{association.name}_type&quot;</span>).<span class="ruby-identifier">to_s</span>
611: 
612:                   <span class="ruby-comment cmt"># support polymorphic belongs_to as &quot;label (Type)&quot;</span>
613:                   <span class="ruby-identifier">row</span>[<span class="ruby-identifier">target_type_name</span>] = <span class="ruby-identifier">target_type</span>
614:                 <span class="ruby-keyword kw">end</span>
615:               <span class="ruby-keyword kw">end</span>
616: 
617:               <span class="ruby-identifier">row</span>[<span class="ruby-identifier">fk_name</span>] = <span class="ruby-constant">Fixtures</span>.<span class="ruby-identifier">identify</span>(<span class="ruby-identifier">value</span>)
618:             <span class="ruby-keyword kw">end</span>
619:           <span class="ruby-keyword kw">when</span> <span class="ruby-identifier">:has_and_belongs_to_many</span>
620:             <span class="ruby-keyword kw">if</span> (<span class="ruby-identifier">targets</span> = <span class="ruby-identifier">row</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">association</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">to_s</span>))
621:               <span class="ruby-identifier">targets</span> = <span class="ruby-identifier">targets</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">targets</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">targets</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp re">/\s*,\s*/</span>)
622:               <span class="ruby-identifier">join_fixtures</span> = <span class="ruby-identifier">habtm_fixtures</span>[<span class="ruby-identifier">association</span>]
623: 
624:               <span class="ruby-identifier">targets</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">target</span><span class="ruby-operator">|</span>
625:                 <span class="ruby-identifier">join_fixtures</span>[<span class="ruby-node">&quot;#{label}_#{target}&quot;</span>] = <span class="ruby-constant">Fixture</span>.<span class="ruby-identifier">new</span>(
626:                   { <span class="ruby-identifier">association</span>.<span class="ruby-identifier">primary_key_name</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">row</span>[<span class="ruby-identifier">primary_key_name</span>],
627:                     <span class="ruby-identifier">association</span>.<span class="ruby-identifier">association_foreign_key</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">Fixtures</span>.<span class="ruby-identifier">identify</span>(<span class="ruby-identifier">target</span>) }, <span class="ruby-keyword kw">nil</span>)
628:               <span class="ruby-keyword kw">end</span>
629:             <span class="ruby-keyword kw">end</span>
630:           <span class="ruby-keyword kw">end</span>
631:         <span class="ruby-keyword kw">end</span>
632:       <span class="ruby-keyword kw">end</span>
633: 
634:       <span class="ruby-ivar">@connection</span>.<span class="ruby-identifier">insert_fixture</span>(<span class="ruby-identifier">fixture</span>, <span class="ruby-ivar">@table_name</span>)
635:     <span class="ruby-keyword kw">end</span>
636: 
637:     <span class="ruby-comment cmt"># insert any HABTM join tables we discovered</span>
638:     <span class="ruby-identifier">habtm_fixtures</span>.<span class="ruby-identifier">values</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">fixture</span><span class="ruby-operator">|</span>
639:       <span class="ruby-identifier">fixture</span>.<span class="ruby-identifier">delete_existing_fixtures</span>
640:       <span class="ruby-identifier">fixture</span>.<span class="ruby-identifier">insert_fixtures</span>
641:     <span class="ruby-keyword kw">end</span>
642:   <span class="ruby-keyword kw">end</span></pre></div>
</div>





</div><div class="clear" id="footer">Generated on Jan 21, 2008 / Allison 2 &copy; 2007 <a href="http://cloudbur.st">Cloudburst, LLC</a></div></div></body></html>