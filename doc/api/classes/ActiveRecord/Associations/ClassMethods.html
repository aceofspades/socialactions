<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><title>Module: ActiveRecord::Associations::ClassMethods</title><link type="text/css" href="../../.././rdoc-style.css" media="screen" rel="stylesheet"/><script type="text/javascript">
// Allison template
// Copyright 2007, 2008 Cloudburst, LLC. Licensed under the AFL 3. See the included LICENSE file.

var href_base = '../../.././rdoc-style.css'.replace(/(.*\/).*/, '$1'); // inline js is good for something  

function $(id) {
    if (document.getElementById)
      elem = document.getElementById(id);
    else if ( document.all )
      elem = eval("document.all." + id);
    else
      return false;
    return elem;
}

  function toggle(id) {
    elem = $(id);
    elemStyle = elem.style;   
    if (elemStyle.display == "block") {
      elemStyle.display = "none"
    } else {
      elemStyle.display = "block"
    }
    return true;
  }

  function toggleText(id) {
    elem = $(id)
    if (m = elem.innerHTML.match(/(Hide)(.*)/)) {
      elem.innerHTML = "Show" + m[2];
    } else if (m = elem.innerHTML.match(/(Show)(.*)/)) {
      elem.innerHTML = "Hide" + m[2];
    }
    return true;
  }

function span(s, klass) {
  return '<span class="' + klass + '">' + s + '</span>';
}
  
function highlightSymbols() {
  pres = document.getElementsByTagName('pre');
  for(var i = 0; i < pres.length; i++) {
    pre = pres[i];
    spans = pre.getElementsByTagName('span');
    for(var k = 0; k < spans.length; k++) {
      span = spans[k];
      if (span.className.match(/ruby-identifier/)) {
        if (span.innerHTML.match(/^:/)) {
          span.className += " ruby-symbol";
        }
      }
    }
  }
}

 function hasClass(obj) {
     var result = false;
     if (obj.getAttributeNode("class") != null) {
         result = obj.getAttributeNode("class").value;
     }
     return result;
  }   

 function stripe() {
    var even = true;
    var color = "#e4ebed";
    var tables = document.getElementsByTagName('table');
    if (tables.length == 0) { return; }
    for (var h = 0; h < tables.length; h++) {
        var trs = tables[h].getElementsByTagName("tr");
        for (var i = 0; i < trs.length; i++) {
          var tds = trs[i].getElementsByTagName("td");
            for (var j = 0; j < tds.length; j++) {       
              if (hasClass(tds[j]) != "first") {                
              var mytd = tds[j];
              if (even) {
                mytd.style.backgroundColor = color;
              }         
            }
          }
          even =  ! even;
      }
    }
  }
  
function ajaxGet(url) {
  url = (href_base + url).replace('/./', '/')
  var req = false;

  if (window.ActiveXObject) {
    try {
      // stupid hack because IE7 disables local Ajax with the native xmlhttprequest object
      // for security purposes. Yet ActiveX still works. Thanks, Microsoft. I hate you. Die.
      req = new ActiveXObject("MSXML2.XMLHTTP.3.0");
    } catch (e) {
      try {
        /* IE 6 and maybe 5, don't know, don't care */
        req = new ActiveXObject("Msxml2.XMLHTTP");
      } catch (e) {
        try {
          req = new ActiveXObject("Microsoft.XMLHTTP");
        } catch (e) {
          req = false;
        }
      }
    }
  }
    
  /* real browsers */
  if (!req && window.XMLHttpRequest) {
    try {
      req = new XMLHttpRequest();
    } catch (e) {
      req = false;
    }
  } 
  
  if (req) {
    req.open('GET', url, false);
    req.send(null);
    return req.responseText;
  } else {
    return "Ajax error";  
  }
}


function addEvent(elm, evType, fn, useCapture) {
	if (elm.addEventListener) {
	  elm.addEventListener(evType, fn, useCapture);  
  	return true;
	} else if (elm.attachEvent) {
  	var r = elm.attachEvent('on' + evType, fn);  
	  return r;  
	} else {
  	elm['on' + evType] = fn;
	}
}

function insertIndices() {
  pages = ["class", "file", "method"]
  for (x in pages) { 
    $(pages[x]).innerHTML += ajaxGet('fr_' + pages[x] + '_index.html').replace(/(href=")/g, '$1' + href_base);
  }
  /* mouseoverify method links */
  links = $('method').getElementsByTagName('a');
  for (var x = 0; x < links.length; x++) {
    if (m = links[x].innerHTML.match(/(.*)\s\((.*)\)/)) {
      links[x].innerHTML = m[1] + '<br>';
      links[x].title = m[2];
    }
  }
  /* this is stupid */
  $('class').style.display = "block";
  $('file').style.display = "block";
  
  /* has to be here because IE7 does not guarantee the onLoad callback order */
  abbreviateIndicesInner(["class", "file"], 25, "a");
  /* same, linkTitle() depends on the class link list */
  linkTitle();
}

function abbreviateIndices() {
  var ids = ["defined_in", "child_of", "includes", "requires", "method", "methods"];
  abbreviateIndicesInner(ids, 25, 'a');
  abbreviateIndicesInner(ids, 25, 'span');
}

function abbreviateIndicesInner(indices, amount, tag) {
  for (var x = 0; x < indices.length; x++) { 
    var the_index = $(indices[x]);
    if (the_index) {
      links = the_index.getElementsByTagName(tag);
      for (var y = 0; y < links.length; y++) {
        var link = links[y];
        if (link.getElementsByTagName('span').length == 0 && link.getElementsByTagName('a').length == 0) {
          // avoid nesting
          link.innerHTML = link.innerHTML.replace(/<br>|\n/gi, '');
          link.title = link.innerHTML;
          link.innerHTML = abbreviate(link.innerHTML, amount) + '<br>';
        }
      }
    }
  }
}

function linkTitle() {
  
  /* grab the correct title element from the index */
  var index_page = ajaxGet('index.html');
  title_text = index_page.match(/<title>(.*)<\/title>/m)[1];
  document.title = title_text + " - " + document.title;
  var p = $('header').getElementsByTagName('p')[0]
  if (p.innerHTML.match(/^\s*$/)) {
    p.innerHTML = title_text;
  } else {
    p.innerHTML = title_text + ": " + p.innerHTML;
  }
  
  /* set the link properly */
  title_link = index_page.match(/<a\s+href="(.*?)"/)[1];
  var element = $('title');
  var item_type = "";
  var item_name = "";
  if (m = element.innerHTML.match(/(Class:|Module:|File:)\s*(.*)/)) {
    item_type = m[1];
    item_name = m[2];
  } else {
    item_name = element.innerHTML;
  }
  element.innerHTML = '<a href="' + href_base + title_link + '">' + item_type + " " + abbreviate(item_name, 45) + '</a>';
  element.getElementsByTagName('a')[0].title = item_name
  
  /* breadcrumb navigation */
  items = item_name.split("::");
  items_new = item_name.split("::");
  file_links = $('class').getElementsByTagName('a');
  for (var x = 0; x < items.length - 1; x++ ){
    var item = items[x];
    link = ("/classes/" + items.slice(0,x).join("/") + "/" + item + ".html").replace('//', '/');
    regex = new RegExp(RegExp.escape(link) + '$');
    for (var y = 0; y < file_links.length; y++) {
      if (file_links[y].href.match(regex)) {
         items_new[x] = '<a href="' + href_base + link + '">' + item + '</a>';
         break;
      }
    }  
  }
  $('item_name').innerHTML = item_type + ' ' + items_new.join(" :: ");
}

function abbreviate(s, size) {
  while (s.length > size) {
    var old_s = s;
    s = s.replace(/\s|\n/mg, '');
    s = s.replace(/([A-Z])[a-z]+/m, '$1');
    if (!s || old_s == s) {
      return "..." + s.substring(s.length - size, s.length);
    }
  }
  return s;
}

function disableSubmit(event) {
  var keyCode = event.keyCode ? event.keyCode : event.which ? event.which : event.charCode;
  if (keyCode == 13) {
    return false;
  } else {
    return true;
  }
}
  
function filterList(id, s, event) {
  
  /* some weak escaping */
  s = s.replace(/[^\w\d\.\_\-\/\:\=\[\]\?\!]/g, '');
  s = RegExp.escape(s);
  
  var show_all = false;
  if (s.match(/^\s*$/)) {
    show_all = true;
  }
  
  links = $(id).getElementsByTagName('a')
  regex = new RegExp(s, 'i');
  
  for (var x = 0; x < links.length; x++) {
    var link = links[x];
    if (show_all) {
      link.style.display = 'inline';
    } else {
       if (link.innerHTML.match(regex)) {        
         link.style.display = 'inline';
       } else {
         link.style.display = 'none';
       }
    }
  }
  return true;
}

RegExp.escape = function(text) {
  if (!arguments.callee.sRE) {
    var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];
    arguments.callee.sRE = new RegExp(
      '(\\' + specials.join('|\\') + ')', 'g'
    );
  }
  return text.replace(arguments.callee.sRE, '\\$1');
}

function hacks() {
  // show the spacer if necessary, 
  divs = document.getElementsByTagName('div');
  for(var x = 0; x < divs.length; x++) {
    if (divs[x].className && divs[x].className.match(/top/)) {
      document.getElementById('spacer').style.display = 'block';
    }
  }
  // remove extra colons from tables
  tds = document.getElementsByTagName('td');
  for(var x = 0; x < tds.length; x++) {
    str = tds[x].innerHTML
    if (str.charAt(str.length - 1) == ":") {
      tds[x].innerHTML = str.slice(0, str.length - 1)
    }
  }
}

addEvent(window, 'load', insertIndices, false);
addEvent(window, 'load', abbreviateIndices, false);
addEvent(window, 'load', stripe, false);
addEvent(window, 'load', highlightSymbols, false);
addEvent(window, 'load', hacks, false);
</script></head><body><div id="container"><div class="curve" id="preheader_curve_0"></div><div class="curve" id="preheader_curve_1"></div><div class="curve" id="preheader_curve_2"></div><div class="curve" id="preheader_curve_3"></div><div class="curve" id="preheader_curve_4"></div><div class="curve" id="preheader_curve_5"></div><div id="header"><p>
</p><span><h1 id="title">
Module: ActiveRecord::Associations::ClassMethods
</h1></span>
</div><div class="clear"></div><div id="left">

<div class="navigation darker top" id="defined_in"><h3>Defined in</h3>

<a href="../../../files/vendor/rails/activerecord/lib/active_record/associations_rb.html">vendor/rails/activerecord/lib/active_record/associations.rb</a>

</div>



<div class="navigation top" id="methods"><h3>Methods</h3>


<a href='#M001270'>
belongs_to<br/>
</a>




<a href='#M001271'>
has_and_belongs_to_many<br/>
</a>




<a href='#M001268'>
has_many<br/>
</a>




<a href='#M001269'>
has_one<br/>
</a>


</div>
<div id="spacer"></div><div class="navigation darker index" id="class_wrapper"><div class="list_header"><h3>All classes</h3></div><div class="list_header_link"><a onclick="toggle('class'); toggleText('class_link'); return false;" href="#" id="class_link">Hide...</a></div><div class="clear"></div><div id="class"><form><label for="filter_class">Filter:&nbsp;&nbsp;</label><input type="text" onKeyUp="return filterList('class', this.value, event);" onKeyPress="return disableSubmit(event);" id="filter_class"></input></form></div></div><div class="navigation darker index" id="file_wrapper"><div class="list_header"><h3>All files</h3></div><div class="list_header_link"><a onclick="toggle('file'); toggleText('file_link'); return false;" href="#" id="file_link">Hide...</a></div><div class="clear"></div><div id="file"><form><label for="filter_file">Filter:&nbsp;&nbsp;</label><input type="text" onKeyUp="return filterList('file', this.value, event);" onKeyPress="return disableSubmit(event);" id="filter_file"></input></form></div></div><div class="navigation darker index" id="method_wrapper"><div class="list_header"><h3>All methods</h3></div><div class="list_header_link"><a onclick="toggle('method'); toggleText('method_link'); return false;" href="#" id="method_link">Show...</a></div><div class="clear"></div><div id="method"><form><label for="filter_method">Filter:&nbsp;&nbsp;</label><input type="text" onKeyUp="return filterList('method', this.value, event);" onKeyPress="return disableSubmit(event);" id="filter_method"></input></form></div></div></div><div id="content">
<h1 id="item_name">Module: ActiveRecord::Associations::ClassMethods</h1>

<div id="description"><p>
Associations are a set of macro-like class methods for tying objects
together through foreign keys. They express relationships like
&quot;Project has one Project Manager&quot; or &quot;Project belongs to a
Portfolio&quot;. Each macro adds a number of methods to the class which are
specialized according to the collection or association symbol and the
options hash. It works much the same way as Ruby&#8216;s own <tt>attr*</tt>
methods. Example:
</p>
<pre>
  class Project &lt; ActiveRecord::Base
    belongs_to              :portfolio
    has_one                 :project_manager
    has_many                :milestones
    has_and_belongs_to_many :categories
  end
</pre>
<p>
The project class now has the following methods (and more) to ease the
traversal and manipulation of its relationships:
</p>
<ul>
<li><tt>Project#portfolio, Project#portfolio=(portfolio),
Project#portfolio.nil?</tt>

</li>
<li><tt>Project#project_manager, Project#project_manager=(project_manager),
Project#project_manager.nil?,</tt>

</li>
<li><tt>Project#milestones.empty?, Project#milestones.size, Project#milestones,
Project#milestones&lt;&lt;(milestone),</tt>
<tt>Project#milestones.delete(milestone),
Project#milestones.find(milestone_id), Project#milestones.find(:all,
options),</tt> <tt>Project#milestones.build, Project#milestones.create</tt>

</li>
<li><tt>Project#categories.empty?, Project#categories.size, Project#categories,
Project#categories&lt;&lt;(category1),</tt>
<tt>Project#categories.delete(category1)</tt>

</li>
</ul>
<h3>A word of warning</h3>
<p>
Don&#8216;t create associations that have the same name as instance methods
of <a href="../Base.html">ActiveRecord::Base</a>. Since the association
adds a method with that name to its model, it will override the inherited
method and break things. For instance, attributes and connection would be
bad choices for association names.
</p>
<h2>Auto-generated methods</h2>
<h3>Singular associations (one-to-one)</h3>
<pre>
                                    |            |  belongs_to  |
  generated methods                 | belongs_to | :polymorphic | has_one
  ----------------------------------+------------+--------------+---------
  #other                            |     X      |      X       |    X
  #other=(other)                    |     X      |      X       |    X
  #build_other(attributes={})       |     X      |              |    X
  #create_other(attributes={})      |     X      |              |    X
  #other.create!(attributes={})     |            |              |    X
  #other.nil?                       |     X      |      X       |
</pre>
<h3>Collection associations (one-to-many / many-to-many)</h3>
<pre>
                                    |       |          | has_many
  generated methods                 | habtm | has_many | :through
  ----------------------------------+-------+----------+----------
  #others                           |   X   |    X     |    X
  #others=(other,other,...)         |   X   |    X     |
  #other_ids                        |   X   |    X     |    X
  #other_ids=(id,id,...)            |   X   |    X     |
  #others&lt;&lt;                         |   X   |    X     |    X
  #others.push                      |   X   |    X     |    X
  #others.concat                    |   X   |    X     |    X
  #others.build(attributes={})      |   X   |    X     |
  #others.create(attributes={})     |   X   |    X     |
  #others.create!(attributes={})    |   X   |    X     |    X
  #others.size                      |   X   |    X     |    X
  #others.length                    |   X   |    X     |    X
  #others.count                     |       |    X     |    X
  #others.sum(args*,&amp;block)         |   X   |    X     |    X
  #others.empty?                    |   X   |    X     |    X
  #others.clear                     |   X   |    X     |
  #others.delete(other,other,...)   |   X   |    X     |    X
  #others.delete_all                |   X   |    X     |
  #others.destroy_all               |   X   |    X     |    X
  #others.find(*args)               |   X   |    X     |    X
  #others.find_first                |   X   |          |
  #others.uniq                      |   X   |    X     |
  #others.reset                     |   X   |    X     |    X
</pre>
<h2>Cardinality and associations</h2>
<p>
ActiveRecord associations can be used to describe relations with
one-to-one, one-to-many and many-to-many cardinality. Each model uses an
association to describe its role in the relation. In each case, the <tt><a
href="ClassMethods.html#M001270">belongs_to</a></tt> association is used in
the model that has the foreign key.
</p>
<h3>One-to-one</h3>
<p>
Use <tt><a href="ClassMethods.html#M001269">has_one</a></tt> in the base,
and <tt><a href="ClassMethods.html#M001270">belongs_to</a></tt> in the
associated model.
</p>
<pre>
  class Employee &lt; ActiveRecord::Base
    has_one :office
  end
  class Office &lt; ActiveRecord::Base
    belongs_to :employee    # foreign key - employee_id
  end
</pre>
<h3>One-to-many</h3>
<p>
Use <tt><a href="ClassMethods.html#M001268">has_many</a></tt> in the base,
and <tt><a href="ClassMethods.html#M001270">belongs_to</a></tt> in the
associated model.
</p>
<pre>
  class Manager &lt; ActiveRecord::Base
    has_many :employees
  end
  class Employee &lt; ActiveRecord::Base
    belongs_to :manager     # foreign key - manager_id
  end
</pre>
<h3>Many-to-many</h3>
<p>
There are two ways to build a many-to-many relationship.
</p>
<p>
The first way uses a <tt><a
href="ClassMethods.html#M001268">has_many</a></tt> association with the
<tt>:through</tt> option and a join model, so there are two stages of
associations.
</p>
<pre>
  class Assignment &lt; ActiveRecord::Base
    belongs_to :programmer  # foreign key - programmer_id
    belongs_to :project     # foreign key - project_id
  end
  class Programmer &lt; ActiveRecord::Base
    has_many :assignments
    has_many :projects, :through =&gt; :assignments
  end
  class Project &lt; ActiveRecord::Base
    has_many :assignments
    has_many :programmers, :through =&gt; :assignments
  end
</pre>
<p>
For the second way, use <tt><a
href="ClassMethods.html#M001271">has_and_belongs_to_many</a></tt> in both
models. This requires a join table that has no corresponding model or
primary key.
</p>
<pre>
  class Programmer &lt; ActiveRecord::Base
    has_and_belongs_to_many :projects       # foreign keys in the join table
  end
  class Project &lt; ActiveRecord::Base
    has_and_belongs_to_many :programmers    # foreign keys in the join table
  end
</pre>
<p>
Choosing which way to build a many-to-many relationship is not always
simple. If you need to work with the relationship model as its own entity,
use <tt><a href="ClassMethods.html#M001268">has_many</a> :through</tt>. Use
<tt><a href="ClassMethods.html#M001271">has_and_belongs_to_many</a></tt>
when working with legacy schemas or when you never work directly with the
relationship itself.
</p>
<h2>Is it a <tt><a href="ClassMethods.html#M001270">belongs_to</a></tt> or <tt><a href="ClassMethods.html#M001269">has_one</a></tt> association?</h2>
<p>
Both express a 1-1 relationship. The difference is mostly where to place
the foreign key, which goes on the table for the class declaring the <tt><a
href="ClassMethods.html#M001270">belongs_to</a></tt> relationship. Example:
</p>
<pre>
  class User &lt; ActiveRecord::Base
    # I reference an account.
    belongs_to :account
  end

  class Account &lt; ActiveRecord::Base
    # One user references me.
    has_one :user
  end
</pre>
<p>
The tables for these classes could look something like:
</p>
<pre>
  CREATE TABLE users (
    id int(11) NOT NULL auto_increment,
    account_id int(11) default NULL,
    name varchar default NULL,
    PRIMARY KEY  (id)
  )

  CREATE TABLE accounts (
    id int(11) NOT NULL auto_increment,
    name varchar default NULL,
    PRIMARY KEY  (id)
  )
</pre>
<h2>Unsaved objects and associations</h2>
<p>
You can manipulate objects and associations before they are saved to the
database, but there is some special behavior you should be aware of, mostly
involving the saving of associated objects.
</p>
<h3>One-to-one associations</h3>
<ul>
<li>Assigning an object to a <tt><a
href="ClassMethods.html#M001269">has_one</a></tt> association automatically
saves that object and the object being replaced (if there is one), in order
to update their primary keys - except if the parent object is unsaved
(<tt>new_record? == true</tt>).

</li>
<li>If either of these saves fail (due to one of the objects being invalid) the
assignment statement returns <tt>false</tt> and the assignment is
cancelled.

</li>
<li>If you wish to assign an object to a <tt><a
href="ClassMethods.html#M001269">has_one</a></tt> association without
saving it, use the <tt>association.build</tt> method (documented below).

</li>
<li>Assigning an object to a <tt><a
href="ClassMethods.html#M001270">belongs_to</a></tt> association does not
save the object, since the foreign key field belongs on the parent. It does
not save the parent either.

</li>
</ul>
<h3>Collections</h3>
<ul>
<li>Adding an object to a collection (<tt><a
href="ClassMethods.html#M001268">has_many</a></tt> or <tt><a
href="ClassMethods.html#M001271">has_and_belongs_to_many</a></tt>)
automatically saves that object, except if the parent object (the owner of
the collection) is not yet stored in the database.

</li>
<li>If saving any of the objects being added to a collection (via <tt>push</tt>
or similar) fails, then <tt>push</tt> returns <tt>false</tt>.

</li>
<li>You can add an object to a collection without automatically saving it by
using the <tt>collection.build</tt> method (documented below).

</li>
<li>All unsaved (<tt>new_record? == true</tt>) members of the collection are
automatically saved when the parent is saved.

</li>
</ul>
<h3>Association callbacks</h3>
<p>
Similar to the normal callbacks that hook into the lifecycle of an Active
Record object, you can also define callbacks that get triggered when you
add an object to or remove an object from an association collection.
Example:
</p>
<pre>
  class Project
    has_and_belongs_to_many :developers, :after_add =&gt; :evaluate_velocity

    def evaluate_velocity(developer)
      ...
    end
  end
</pre>
<p>
It&#8216;s possible to stack callbacks by passing them as an array.
Example:
</p>
<pre>
  class Project
    has_and_belongs_to_many :developers, :after_add =&gt; [:evaluate_velocity, Proc.new { |p, d| p.shipping_date = Time.now}]
  end
</pre>
<p>
Possible callbacks are: <tt>before_add</tt>, <tt>after_add</tt>,
<tt>before_remove</tt> and <tt>after_remove</tt>.
</p>
<p>
Should any of the <tt>before_add</tt> callbacks throw an exception, the
object does not get added to the collection. Same with the
<tt>before_remove</tt> callbacks; if an exception is thrown the object
doesn&#8216;t get removed.
</p>
<h3>Association extensions</h3>
<p>
The proxy objects that control the access to associations can be extended
through anonymous modules. This is especially beneficial for adding new
finders, creators, and other factory-type methods that are only used as
part of this association. Example:
</p>
<pre>
  class Account &lt; ActiveRecord::Base
    has_many :people do
      def find_or_create_by_name(name)
        first_name, last_name = name.split(&quot; &quot;, 2)
        find_or_create_by_first_name_and_last_name(first_name, last_name)
      end
    end
  end

  person = Account.find(:first).people.find_or_create_by_name(&quot;David Heinemeier Hansson&quot;)
  person.first_name # =&gt; &quot;David&quot;
  person.last_name  # =&gt; &quot;Heinemeier Hansson&quot;
</pre>
<p>
If you need to share the same extensions between many associations, you can
use a named extension module. Example:
</p>
<pre>
  module FindOrCreateByNameExtension
    def find_or_create_by_name(name)
      first_name, last_name = name.split(&quot; &quot;, 2)
      find_or_create_by_first_name_and_last_name(first_name, last_name)
    end
  end

  class Account &lt; ActiveRecord::Base
    has_many :people, :extend =&gt; FindOrCreateByNameExtension
  end

  class Company &lt; ActiveRecord::Base
    has_many :people, :extend =&gt; FindOrCreateByNameExtension
  end
</pre>
<p>
If you need to use multiple named extension modules, you can specify an
array of modules with the <tt>:extend</tt> option. In the case of name
conflicts between methods in the modules, methods in modules later in the
array supercede those earlier in the array. Example:
</p>
<pre>
  class Account &lt; ActiveRecord::Base
    has_many :people, :extend =&gt; [FindOrCreateByNameExtension, FindRecentExtension]
  end
</pre>
<p>
Some extensions can only be made to work with knowledge of the association
proxy&#8216;s internals. Extensions can access relevant state using
accessors on the association proxy:
</p>
<ul>
<li><tt>proxy_owner</tt> - Returns the object the association is part of.

</li>
<li><tt>proxy_reflection</tt> - Returns the reflection object that describes
the association.

</li>
<li><tt>proxy_target</tt> - Returns the associated object for <tt><a
href="ClassMethods.html#M001270">belongs_to</a></tt> and <tt><a
href="ClassMethods.html#M001269">has_one</a></tt>, or the collection of
associated objects for <tt><a
href="ClassMethods.html#M001268">has_many</a></tt> and <tt><a
href="ClassMethods.html#M001271">has_and_belongs_to_many</a></tt>.

</li>
</ul>
<h3>Association Join Models</h3>
<p>
Has Many associations can be configured with the <tt>:through</tt> option
to use an explicit join model to retrieve the data. This operates similarly
to a <tt><a
href="ClassMethods.html#M001271">has_and_belongs_to_many</a></tt>
association. The advantage is that you&#8216;re able to add validations,
callbacks, and extra attributes on the join model. Consider the following
schema:
</p>
<pre>
  class Author &lt; ActiveRecord::Base
    has_many :authorships
    has_many :books, :through =&gt; :authorships
  end

  class Authorship &lt; ActiveRecord::Base
    belongs_to :author
    belongs_to :book
  end

  @author = Author.find :first
  @author.authorships.collect { |a| a.book } # selects all books that the author's authorships belong to.
  @author.books                              # selects all books by using the Authorship join model
</pre>
<p>
You can also go through a <tt><a
href="ClassMethods.html#M001268">has_many</a></tt> association on the join
model:
</p>
<pre>
  class Firm &lt; ActiveRecord::Base
    has_many   :clients
    has_many   :invoices, :through =&gt; :clients
  end

  class Client &lt; ActiveRecord::Base
    belongs_to :firm
    has_many   :invoices
  end

  class Invoice &lt; ActiveRecord::Base
    belongs_to :client
  end

  @firm = Firm.find :first
  @firm.clients.collect { |c| c.invoices }.flatten # select all invoices for all clients of the firm
  @firm.invoices                                   # selects all invoices by going through the Client join model.
</pre>
<h3>Polymorphic Associations</h3>
<p>
Polymorphic associations on models are not restricted on what types of
models they can be associated with. Rather, they specify an interface that
a <tt><a href="ClassMethods.html#M001268">has_many</a></tt> association
must adhere to.
</p>
<pre>
  class Asset &lt; ActiveRecord::Base
    belongs_to :attachable, :polymorphic =&gt; true
  end

  class Post &lt; ActiveRecord::Base
    has_many :assets, :as =&gt; :attachable         # The :as option specifies the polymorphic interface to use.
  end

  @asset.attachable = @post
</pre>
<p>
This works by using a type column in addition to a foreign key to specify
the associated record. In the Asset example, you&#8216;d need an
<tt>attachable_id</tt> integer column and an <tt>attachable_type</tt>
string column.
</p>
<p>
Using polymorphic associations in combination with single table inheritance
(STI) is a little tricky. In order for the associations to work as
expected, ensure that you store the base model for the STI models in the
type column of the polymorphic association. To continue with the asset
example above, suppose there are guest posts and member posts that use the
posts table for STI. In this case, there must be a <tt>type</tt> column in
the posts table.
</p>
<pre>
  class Asset &lt; ActiveRecord::Base
    belongs_to :attachable, :polymorphic =&gt; true

    def attachable_type=(sType)
       super(sType.to_s.classify.constantize.base_class.to_s)
    end
  end

  class Post &lt; ActiveRecord::Base
    # because we store &quot;Post&quot; in attachable_type now :dependent =&gt; :destroy will work
    has_many :assets, :as =&gt; :attachable, :dependent =&gt; :destroy
  end

  class GuestPost &lt; Post
  end

  class MemberPost &lt; Post
  end
</pre>
<h2>Caching</h2>
<p>
All of the methods are built on a simple caching principle that will keep
the result of the last query around unless specifically instructed not to.
The cache is even shared across methods to make it even cheaper to use the
macro-added methods without worrying too much about performance at the
first go. Example:
</p>
<pre>
  project.milestones             # fetches milestones from the database
  project.milestones.size        # uses the milestone cache
  project.milestones.empty?      # uses the milestone cache
  project.milestones(true).size  # fetches milestones from the database
  project.milestones             # uses the milestone cache
</pre>
<h2>Eager loading of associations</h2>
<p>
Eager loading is a way to find objects of a certain class and a number of
named associations along with it in a single SQL call. This is one of the
easiest ways of to prevent the dreaded 1+N problem in which fetching 100
posts that each need to display their author triggers 101 database queries.
Through the use of eager loading, the 101 queries can be reduced to 1.
Example:
</p>
<pre>
  class Post &lt; ActiveRecord::Base
    belongs_to :author
    has_many   :comments
  end
</pre>
<p>
Consider the following loop using the class above:
</p>
<pre>
  for post in Post.find(:all)
    puts &quot;Post:            &quot; + post.title
    puts &quot;Written by:      &quot; + post.author.name
    puts &quot;Last comment on: &quot; + post.comments.first.created_on
  end
</pre>
<p>
To iterate over these one hundred posts, we&#8216;ll generate 201 database
queries. Let&#8216;s first just optimize it for retrieving the author:
</p>
<pre>
  for post in Post.find(:all, :include =&gt; :author)
</pre>
<p>
This references the name of the <tt><a
href="ClassMethods.html#M001270">belongs_to</a></tt> association that also
used the <tt>:author</tt> symbol, so the find will now weave in a join
something like this: <tt>LEFT OUTER JOIN authors ON authors.id =
posts.author_id</tt>. Doing so will cut down the number of queries from 201
to 101.
</p>
<p>
We can improve upon the situation further by referencing both associations
in the finder with:
</p>
<pre>
  for post in Post.find(:all, :include =&gt; [ :author, :comments ])
</pre>
<p>
That&#8216;ll add another join along the lines of: <tt>LEFT OUTER JOIN
comments ON comments.post_id = posts.id</tt>. And we&#8216;ll be down to 1
query.
</p>
<p>
To include a deep hierarchy of associations, use a hash:
</p>
<pre>
  for post in Post.find(:all, :include =&gt; [ :author, { :comments =&gt; { :author =&gt; :gravatar } } ])
</pre>
<p>
That&#8216;ll grab not only all the comments but all their authors and
gravatar pictures. You can mix and match symbols, arrays and hashes in any
combination to describe the associations you want to load.
</p>
<p>
All of this power shouldn&#8216;t fool you into thinking that you can pull
out huge amounts of data with no performance penalty just because
you&#8216;ve reduced the number of queries. The database still needs to
send all the data to Active Record and it still needs to be processed. So
it&#8216;s no catch-all for performance problems, but it&#8216;s a great
way to cut down on the number of queries in a situation as the one
described above.
</p>
<p>
Since the eager loading pulls from multiple tables, you&#8216;ll have to
disambiguate any column references in both conditions and orders. So
<tt>:order =&gt; &quot;posts.id DESC&quot;</tt> will work while <tt>:order
=&gt; &quot;id DESC&quot;</tt> will not. Because eager loading generates
the <tt>SELECT</tt> statement too, the <tt>:select</tt> option is ignored.
</p>
<p>
You can use eager loading on multiple associations from the same table, but
you cannot use those associations in orders and conditions as there is
currently not any way to disambiguate them. Eager loading will not pull
additional attributes on join tables, so &quot;rich associations&quot; with
<tt><a href="ClassMethods.html#M001271">has_and_belongs_to_many</a></tt>
are not a good fit for eager loading.
</p>
<p>
When eager loaded, conditions are interpolated in the context of the model
class, not the model instance. Conditions are lazily interpolated before
the actual model exists.
</p>
<p>
Eager loading is not supported with polymorphic associations up to (and
including) version 2.0.2. Given
</p>
<pre>
  class Address &lt; ActiveRecord::Base
    belongs_to :addressable, :polymorphic =&gt; true
  end
</pre>
<p>
a call that tries to eager load the addressable model
</p>
<pre>
  Address.find(:all, :include =&gt; :addressable)   # INVALID
</pre>
<p>
will raise <tt>ActiveRecord::EagerLoadPolymorphicError</tt>. The reason is
that the parent model&#8216;s type is a column value so its corresponding
table name cannot be put in the FROM/JOIN clauses of that early query.
</p>
<p>
In versions greater than 2.0.2 eager loading in polymorphic associations is
supported thanks to a change in the overall preloading strategy.
</p>
<p>
It does work the other way around though: if the <tt>User</tt> model is
<tt>addressable</tt> you can eager load their addresses with
<tt>:include</tt> just fine, every piece needed to construct the query is
known beforehand.
</p>
<h2>Table Aliasing</h2>
<p>
ActiveRecord uses table aliasing in the case that a table is referenced
multiple times in a join. If a table is referenced only once, the standard
table name is used. The second time, the table is aliased as
<tt>#{reflection_name}_#{parent_table_name}</tt>. Indexes are appended for
any more successive uses of the table name.
</p>
<pre>
  Post.find :all, :include =&gt; :comments
  # =&gt; SELECT ... FROM posts LEFT OUTER JOIN comments ON ...
  Post.find :all, :include =&gt; :special_comments # STI
  # =&gt; SELECT ... FROM posts LEFT OUTER JOIN comments ON ... AND comments.type = 'SpecialComment'
  Post.find :all, :include =&gt; [:comments, :special_comments] # special_comments is the reflection name, posts is the parent table name
  # =&gt; SELECT ... FROM posts LEFT OUTER JOIN comments ON ... LEFT OUTER JOIN comments special_comments_posts
</pre>
<p>
Acts as tree example:
</p>
<pre>
  TreeMixin.find :all, :include =&gt; :children
  # =&gt; SELECT ... FROM mixins LEFT OUTER JOIN mixins childrens_mixins ...
  TreeMixin.find :all, :include =&gt; {:children =&gt; :parent} # using cascading eager includes
  # =&gt; SELECT ... FROM mixins LEFT OUTER JOIN mixins childrens_mixins ...
                              LEFT OUTER JOIN parents_mixins ...
  TreeMixin.find :all, :include =&gt; {:children =&gt; {:parent =&gt; :children}}
  # =&gt; SELECT ... FROM mixins LEFT OUTER JOIN mixins childrens_mixins ...
                              LEFT OUTER JOIN parents_mixins ...
                              LEFT OUTER JOIN mixins childrens_mixins_2
</pre>
<p>
Has and Belongs to Many join tables use the same idea, but add a
<tt>_join</tt> suffix:
</p>
<pre>
  Post.find :all, :include =&gt; :categories
  # =&gt; SELECT ... FROM posts LEFT OUTER JOIN categories_posts ... LEFT OUTER JOIN categories ...
  Post.find :all, :include =&gt; {:categories =&gt; :posts}
  # =&gt; SELECT ... FROM posts LEFT OUTER JOIN categories_posts ... LEFT OUTER JOIN categories ...
                             LEFT OUTER JOIN categories_posts posts_categories_join LEFT OUTER JOIN posts posts_categories
  Post.find :all, :include =&gt; {:categories =&gt; {:posts =&gt; :categories}}
  # =&gt; SELECT ... FROM posts LEFT OUTER JOIN categories_posts ... LEFT OUTER JOIN categories ...
                             LEFT OUTER JOIN categories_posts posts_categories_join LEFT OUTER JOIN posts posts_categories
                             LEFT OUTER JOIN categories_posts categories_posts_join LEFT OUTER JOIN categories categories_posts
</pre>
<p>
If you wish to specify your own custom joins using a <tt>:joins</tt>
option, those table names will take precedence over the eager associations:
</p>
<pre>
  Post.find :all, :include =&gt; :comments, :joins =&gt; &quot;inner join comments ...&quot;
  # =&gt; SELECT ... FROM posts LEFT OUTER JOIN comments_posts ON ... INNER JOIN comments ...
  Post.find :all, :include =&gt; [:comments, :special_comments], :joins =&gt; &quot;inner join comments ...&quot;
  # =&gt; SELECT ... FROM posts LEFT OUTER JOIN comments comments_posts ON ...
                             LEFT OUTER JOIN comments special_comments_posts ...
                             INNER JOIN comments ...
</pre>
<p>
Table aliases are automatically truncated according to the maximum length
of table identifiers according to the specific database.
</p>
<h2>Modules</h2>
<p>
By default, associations will look for objects within the current module
scope. Consider:
</p>
<pre>
  module MyApplication
    module Business
      class Firm &lt; ActiveRecord::Base
         has_many :clients
       end

      class Company &lt; ActiveRecord::Base; end
    end
  end
</pre>
<p>
When <tt>Firm#clients</tt> is called, it will in turn call
<tt>MyApplication::Business::Company.find(firm.id)</tt>. If you want to
associate with a class in another module scope, this can be done by
specifying the complete class name. Example:
</p>
<pre>
  module MyApplication
    module Business
      class Firm &lt; ActiveRecord::Base; end
    end

    module Billing
      class Account &lt; ActiveRecord::Base
        belongs_to :firm, :class_name =&gt; &quot;MyApplication::Business::Firm&quot;
      end
    end
  end
</pre>
<h2>Type safety with <tt><a href="../AssociationTypeMismatch.html">ActiveRecord::AssociationTypeMismatch</a></tt></h2>
<p>
If you attempt to assign an object to an association that doesn&#8216;t
match the inferred or specified <tt>:class_name</tt>, you&#8216;ll get an
<tt><a
href="../AssociationTypeMismatch.html">ActiveRecord::AssociationTypeMismatch</a></tt>.
</p>
<h2>Options</h2>
<p>
All of the association macros can be specialized through options. This
makes cases more complex than the simple and guessable ones possible.
</p>
</div>




<p></p>






<h1>Public Instance Methods</h1>


<a class="small" name="M001270"><br/></a>
<div class="method_block"><h3>
<a href='#M001270'>


belongs_to

(association_id, options = {})

</a>
</h3>
<p>
Adds the following methods for retrieval and query for a single associated
object for which this object holds an id: <tt>association</tt> is replaced
with the symbol passed as the first argument, so <tt><a
href="ClassMethods.html#M001270">belongs_to</a> :author</tt> would add
among others <tt>author.nil?</tt>.
</p>
<ul>
<li><tt>association(force_reload = false)</tt> - returns the associated object.
<tt>nil</tt> is returned if none is found.

</li>
<li><tt>association=(associate)</tt> - assigns the associate object, extracts
the primary key, and sets it as the foreign key.

</li>
<li><tt>association.nil?</tt> - returns <tt>true</tt> if there is no associated
object.

</li>
<li><tt>build_association(attributes = {})</tt> - returns a new object of the
associated type that has been instantiated with <tt>attributes</tt> and
linked to this object through a foreign key, but has not yet been saved.

</li>
<li><tt>create_association(attributes = {})</tt> - returns a new object of the
associated type that has been instantiated with <tt>attributes</tt>, linked
to this object through a foreign key, and that has already been saved (if
it passed the validation).

</li>
</ul>
<p>
Example: A Post class declares <tt><a
href="ClassMethods.html#M001270">belongs_to</a> :author</tt>, which will
add:
</p>
<ul>
<li><tt>Post#author</tt> (similar to <tt>Author.find(author_id)</tt>)

</li>
<li><tt>Post#author=(author)</tt> (similar to <tt>post.author_id =
author.id</tt>)

</li>
<li><tt>Post#author?</tt> (similar to <tt>post.author == some_author</tt>)

</li>
<li><tt>Post#author.nil?</tt>

</li>
<li><tt>Post#build_author</tt> (similar to <tt>post.author = Author.new</tt>)

</li>
<li><tt>Post#create_author</tt> (similar to <tt>post.author = Author.new;
post.author.save; post.author</tt>)

</li>
</ul>
<p>
The declaration can also include an options hash to specialize the behavior
of the association.
</p>
<p>
Options are:
</p>
<ul>
<li><tt>:class_name</tt> - specify the class name of the association. Use it
only if that name can&#8216;t be inferred from the association name. So
<tt><a href="ClassMethods.html#M001269">has_one</a> :author</tt> will by
default be linked to the <tt>Author</tt> class, but if the real class name
is <tt>Person</tt>, you&#8216;ll have to specify it with this option.

</li>
<li><tt>:conditions</tt> - specify the conditions that the associated object
must meet in order to be included as a <tt>WHERE</tt> SQL fragment, such as
<tt>authorized = 1</tt>.

</li>
<li><tt>:order</tt> - specify the order in which the associated objects are
returned as an <tt>ORDER BY</tt> SQL fragment, such as <tt>last_name,
first_name DESC</tt>

</li>
<li><tt>:foreign_key</tt> - specify the foreign key used for the association.
By default this is guessed to be the name of the association with an
<tt>_id</tt> suffix. So a class that defines a +<a
href="ClassMethods.html#M001270">belongs_to</a> :person+ association will
use <tt>person_id</tt> as the default <tt>foreign_key</tt>. Similarly, +<a
href="ClassMethods.html#M001270">belongs_to</a> :favorite_person,
:class_name =&gt; &quot;Person&quot;+ will use a foreign key of
<tt>favorite_person_id</tt>.

</li>
<li><tt>:dependent</tt> - if set to <tt>:destroy</tt>, the associated object is
destroyed when this object is. If set to <tt>:delete</tt>, the associated
object is deleted <b>without</b> calling its destroy method. This option
should not be specified when <tt><a
href="ClassMethods.html#M001270">belongs_to</a></tt> is used in conjunction
with a <tt><a href="ClassMethods.html#M001268">has_many</a></tt>
relationship on another class because of the potential to leave orphaned
records behind.

</li>
<li><tt>:counter_cache</tt> - caches the number of belonging objects on the
associate class through the use of <tt>increment_counter</tt> and
<tt>decrement_counter</tt>. The counter cache is incremented when an object
of this class is created and decremented when it&#8216;s destroyed. This
requires that a column named <tt>#{table_name}_count</tt> (such as
<tt>comments_count</tt> for a belonging <tt>Comment</tt> class) is used on
the associate class (such as a <tt>Post</tt> class). You can also specify a
custom counter cache column by providing a column name instead of a
<tt>true</tt>/<tt>false</tt> value to this option (e.g., <tt>:counter_cache
=&gt; :my_custom_counter</tt>.) Note: Specifying a counter_cache will add
it to that model&#8216;s list of readonly attributes using attr_readonly.

</li>
<li><tt>:include</tt> - specify second-order associations that should be eager
loaded when this object is loaded. Not allowed if the association is
polymorphic.

</li>
<li><tt>:polymorphic</tt> - specify this association is a polymorphic
association by passing <tt>true</tt>. Note: If you&#8216;ve enabled the
counter cache, then you may want to add the counter cache attribute to the
attr_readonly list in the associated classes (e.g. class Post;
attr_readonly :comments_count; end).

</li>
<li><tt>:readonly</tt> - if set to <tt>true</tt>, the associated object is
readonly through the association.

</li>
</ul>
<p>
Option examples:
</p>
<pre>
  belongs_to :firm, :foreign_key =&gt; &quot;client_of&quot;
  belongs_to :author, :class_name =&gt; &quot;Person&quot;, :foreign_key =&gt; &quot;author_id&quot;
  belongs_to :valid_coupon, :class_name =&gt; &quot;Coupon&quot;, :foreign_key =&gt; &quot;coupon_id&quot;,
             :conditions =&gt; 'discounts &gt; #{payments_count}'
  belongs_to :attachable, :polymorphic =&gt; true
  belongs_to :project, :readonly =&gt; true
</pre>

<p class="source_link" id="M001270-show-link"><a onclick="toggle('M001270-source'); toggleText('M001270-link'); return false;" href="#" id="M001270-link">Show source...</a></p><div class="source" id="M001270-source"><pre>     <span class="ruby-comment cmt"># File vendor/rails/activerecord/lib/active_record/associations.rb, line 827</span>
827:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">belongs_to</span>(<span class="ruby-identifier">association_id</span>, <span class="ruby-identifier">options</span> = {})
828:         <span class="ruby-identifier">reflection</span> = <span class="ruby-identifier">create_belongs_to_reflection</span>(<span class="ruby-identifier">association_id</span>, <span class="ruby-identifier">options</span>)
829: 
830:         <span class="ruby-identifier">ivar</span> = <span class="ruby-node">&quot;@#{reflection.name}&quot;</span>
831: 
832:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">options</span>[<span class="ruby-identifier">:polymorphic</span>]
833:           <span class="ruby-identifier">association_accessor_methods</span>(<span class="ruby-identifier">reflection</span>, <span class="ruby-constant">BelongsToPolymorphicAssociation</span>)
834: 
835:           <span class="ruby-identifier">method_name</span> = <span class="ruby-node">&quot;polymorphic_belongs_to_before_save_for_#{reflection.name}&quot;</span>.<span class="ruby-identifier">to_sym</span>
836:           <span class="ruby-identifier">define_method</span>(<span class="ruby-identifier">method_name</span>) <span class="ruby-keyword kw">do</span>
837:             <span class="ruby-identifier">association</span> = <span class="ruby-identifier">instance_variable_get</span>(<span class="ruby-node">&quot;#{ivar}&quot;</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">instance_variable_defined?</span>(<span class="ruby-node">&quot;#{ivar}&quot;</span>)
838: 
839:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">association</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">association</span>.<span class="ruby-identifier">target</span>
840:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">association</span>.<span class="ruby-identifier">new_record?</span>
841:                 <span class="ruby-identifier">association</span>.<span class="ruby-identifier">save</span>(<span class="ruby-keyword kw">true</span>)
842:               <span class="ruby-keyword kw">end</span>
843: 
844:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">association</span>.<span class="ruby-identifier">updated?</span>
845:                 <span class="ruby-keyword kw">self</span>[<span class="ruby-node">&quot;#{reflection.primary_key_name}&quot;</span>] = <span class="ruby-identifier">association</span>.<span class="ruby-identifier">id</span>
846:                 <span class="ruby-keyword kw">self</span>[<span class="ruby-node">&quot;#{reflection.options[:foreign_type]}&quot;</span>] = <span class="ruby-identifier">association</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">base_class</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">to_s</span>
847:               <span class="ruby-keyword kw">end</span>
848:             <span class="ruby-keyword kw">end</span>
849:           <span class="ruby-keyword kw">end</span>
850:           <span class="ruby-identifier">before_save</span> <span class="ruby-identifier">method_name</span>
851:         <span class="ruby-keyword kw">else</span>
852:           <span class="ruby-identifier">association_accessor_methods</span>(<span class="ruby-identifier">reflection</span>, <span class="ruby-constant">BelongsToAssociation</span>)
853:           <span class="ruby-identifier">association_constructor_method</span>(<span class="ruby-identifier">:build</span>,  <span class="ruby-identifier">reflection</span>, <span class="ruby-constant">BelongsToAssociation</span>)
854:           <span class="ruby-identifier">association_constructor_method</span>(<span class="ruby-identifier">:create</span>, <span class="ruby-identifier">reflection</span>, <span class="ruby-constant">BelongsToAssociation</span>)
855: 
856:           <span class="ruby-identifier">method_name</span> = <span class="ruby-node">&quot;belongs_to_before_save_for_#{reflection.name}&quot;</span>.<span class="ruby-identifier">to_sym</span>
857:           <span class="ruby-identifier">define_method</span>(<span class="ruby-identifier">method_name</span>) <span class="ruby-keyword kw">do</span>
858:             <span class="ruby-identifier">association</span> = <span class="ruby-identifier">instance_variable_get</span>(<span class="ruby-node">&quot;#{ivar}&quot;</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">instance_variable_defined?</span>(<span class="ruby-node">&quot;#{ivar}&quot;</span>)
859: 
860:             <span class="ruby-keyword kw">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">association</span>.<span class="ruby-identifier">nil?</span>
861:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">association</span>.<span class="ruby-identifier">new_record?</span>
862:                 <span class="ruby-identifier">association</span>.<span class="ruby-identifier">save</span>(<span class="ruby-keyword kw">true</span>)
863:               <span class="ruby-keyword kw">end</span>
864: 
865:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">association</span>.<span class="ruby-identifier">updated?</span>
866:                 <span class="ruby-keyword kw">self</span>[<span class="ruby-node">&quot;#{reflection.primary_key_name}&quot;</span>] = <span class="ruby-identifier">association</span>.<span class="ruby-identifier">id</span>
867:               <span class="ruby-keyword kw">end</span>
868:             <span class="ruby-keyword kw">end</span>
869:           <span class="ruby-keyword kw">end</span>
870:           <span class="ruby-identifier">before_save</span> <span class="ruby-identifier">method_name</span>
871:         <span class="ruby-keyword kw">end</span>
872: 
873:         <span class="ruby-comment cmt"># Create the callbacks to update counter cache</span>
874:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:counter_cache</span>]
875:           <span class="ruby-identifier">cache_column</span> = <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:counter_cache</span>] <span class="ruby-operator">==</span> <span class="ruby-keyword kw">true</span> <span class="ruby-operator">?</span>
876:             <span class="ruby-node">&quot;#{self.to_s.underscore.pluralize}_count&quot;</span> <span class="ruby-operator">:</span>
877:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:counter_cache</span>]
878: 
879:           <span class="ruby-identifier">method_name</span> = <span class="ruby-node">&quot;belongs_to_counter_cache_after_create_for_#{reflection.name}&quot;</span>.<span class="ruby-identifier">to_sym</span>
880:           <span class="ruby-identifier">define_method</span>(<span class="ruby-identifier">method_name</span>) <span class="ruby-keyword kw">do</span>
881:             <span class="ruby-identifier">association</span> = <span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{reflection.name}&quot;</span>)
882:             <span class="ruby-identifier">association</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">increment_counter</span>(<span class="ruby-node">&quot;#{cache_column}&quot;</span>, <span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{reflection.primary_key_name}&quot;</span>)) <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">association</span>.<span class="ruby-identifier">nil?</span>
883:           <span class="ruby-keyword kw">end</span>
884:           <span class="ruby-identifier">after_create</span> <span class="ruby-identifier">method_name</span>
885: 
886:           <span class="ruby-identifier">method_name</span> = <span class="ruby-node">&quot;belongs_to_counter_cache_before_destroy_for_#{reflection.name}&quot;</span>.<span class="ruby-identifier">to_sym</span>
887:           <span class="ruby-identifier">define_method</span>(<span class="ruby-identifier">method_name</span>) <span class="ruby-keyword kw">do</span>
888:             <span class="ruby-identifier">association</span> = <span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{reflection.name}&quot;</span>)
889:             <span class="ruby-identifier">association</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">decrement_counter</span>(<span class="ruby-node">&quot;#{cache_column}&quot;</span>, <span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{reflection.primary_key_name}&quot;</span>)) <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">association</span>.<span class="ruby-identifier">nil?</span>
890:           <span class="ruby-keyword kw">end</span>
891:           <span class="ruby-identifier">before_destroy</span> <span class="ruby-identifier">method_name</span>
892: 
893:           <span class="ruby-identifier">module_eval</span>(
894:             <span class="ruby-node">&quot;#{reflection.class_name}.send(:attr_readonly,\&quot;#{cache_column}\&quot;.intern) if defined?(#{reflection.class_name}) &amp;&amp; #{reflection.class_name}.respond_to?(:attr_readonly)&quot;</span>
895:           )
896:         <span class="ruby-keyword kw">end</span>
897: 
898:         <span class="ruby-identifier">configure_dependency_for_belongs_to</span>(<span class="ruby-identifier">reflection</span>)
899:       <span class="ruby-keyword kw">end</span></pre></div>
</div>

<a class="small" name="M001271"><br/></a>
<div class="method_block"><h3>
<a href='#M001271'>


has_and_belongs_to_many

(association_id, options = {}, &amp;extension)

</a>
</h3>
<p>
Associates two classes via an intermediate join table. Unless the join
table is explicitly specified as an option, it is guessed using the lexical
order of the class names. So a join between <tt>Developer</tt> and
<tt>Project</tt> will give the default join table name of
<tt>developers_projects</tt> because &quot;D&quot; outranks &quot;P&quot;.
Note that this precedence is calculated using the <tt>&lt;</tt> operator
for <tt>String</tt>. This means that if the strings are of different
lengths, and the strings are equal when compared up to the shortest length,
then the longer string is considered of higher lexical precedence than the
shorter one. For example, one would expect the tables <tt>paper_boxes</tt>
and <tt>papers</tt> to generate a join table name of
<tt>papers_paper_boxes</tt> because of the length of the name
<tt>paper_boxes</tt>, but it in fact generates a join table name of
<tt>paper_boxes_papers</tt>. Be aware of this caveat, and use the custom
<tt>join_table</tt> option if you need to.
</p>
<p>
Deprecated: Any additional fields added to the join table will be placed as
attributes when pulling records out through <tt><a
href="ClassMethods.html#M001271">has_and_belongs_to_many</a></tt>
associations. Records returned from join tables with additional attributes
will be marked as <tt>ReadOnly</tt> (because we can&#8216;t save changes to
the additional attributes). It&#8216;s strongly recommended that you
upgrade any associations with attributes to a real join model (see
introduction).
</p>
<p>
Adds the following methods for retrieval and query: <tt>collection</tt> is
replaced with the symbol passed as the first argument, so <tt><a
href="ClassMethods.html#M001271">has_and_belongs_to_many</a>
:categories</tt> would add among others <tt>categories.empty?</tt>.
</p>
<ul>
<li><tt>collection(force_reload = false)</tt> - returns an array of all the
associated objects. An empty array is returned if none are found.

</li>
<li><tt>collection&lt;&lt;(object, &#8230;)</tt> - adds one or more objects to
the collection by creating associations in the join table
(<tt>collection.push</tt> and <tt>collection.concat</tt> are aliases to
this method).

</li>
<li><tt>collection.delete(object, &#8230;)</tt> - removes one or more objects
from the collection by removing their associations from the join table.
This does not destroy the objects.

</li>
<li><tt>collection=objects</tt> - replaces the collection&#8216;s content by
deleting and adding objects as appropriate.

</li>
<li><tt>collection_singular_ids</tt> - returns an array of the associated
objects&#8217; ids

</li>
<li><tt>collection_singular_ids=ids</tt> - replace the collection by the
objects identified by the primary keys in <tt>ids</tt>

</li>
<li><tt>collection.clear</tt> - removes every object from the collection. This
does not destroy the objects.

</li>
<li><tt>collection.empty?</tt> - returns <tt>true</tt> if there are no
associated objects.

</li>
<li><tt>collection.size</tt> - returns the number of associated objects.

</li>
<li><tt>collection.find(id)</tt> - finds an associated object responding to the
<tt>id</tt> and that meets the condition that it has to be associated with
this object.

</li>
<li><tt>collection.build(attributes = {})</tt> - returns a new object of the
collection type that has been instantiated with <tt>attributes</tt> and
linked to this object through the join table, but has not yet been saved.

</li>
<li><tt>collection.create(attributes = {})</tt> - returns a new object of the
collection type that has been instantiated with <tt>attributes</tt>, linked
to this object through the join table, and that has already been saved (if
it passed the validation).

</li>
</ul>
<p>
Example: A Developer class declares <tt><a
href="ClassMethods.html#M001271">has_and_belongs_to_many</a>
:projects</tt>, which will add:
</p>
<ul>
<li><tt>Developer#projects</tt>

</li>
<li><tt>Developer#projects&lt;&lt;</tt>

</li>
<li><tt>Developer#projects.delete</tt>

</li>
<li><tt>Developer#projects=</tt>

</li>
<li><tt>Developer#project_ids</tt>

</li>
<li><tt>Developer#project_ids=</tt>

</li>
<li><tt>Developer#projects.clear</tt>

</li>
<li><tt>Developer#projects.empty?</tt>

</li>
<li><tt>Developer#projects.size</tt>

</li>
<li><tt>Developer#projects.find(id)</tt>

</li>
<li><tt>Developer#projects.build</tt> (similar to
<tt>Project.new(&quot;project_id&quot; =&gt; id)</tt>)

</li>
<li><tt>Developer#projects.create</tt> (similar to <tt>c =
Project.new(&quot;project_id&quot; =&gt; id); c.save; c</tt>)

</li>
</ul>
<p>
The declaration may include an options hash to specialize the behavior of
the association.
</p>
<p>
Options are:
</p>
<ul>
<li><tt>:class_name</tt> - specify the class name of the association. Use it
only if that name can&#8216;t be inferred from the association name. So
<tt><a href="ClassMethods.html#M001271">has_and_belongs_to_many</a>
:projects</tt> will by default be linked to the <tt>Project</tt> class, but
if the real class name is <tt>SuperProject</tt>, you&#8216;ll have to
specify it with this option.

</li>
<li><tt>:join_table</tt> - specify the name of the join table if the default
based on lexical order isn&#8216;t what you want. WARNING: If you&#8216;re
overwriting the table name of either class, the <tt>table_name</tt> method
MUST be declared underneath any <tt><a
href="ClassMethods.html#M001271">has_and_belongs_to_many</a></tt>
declaration in order to work.

</li>
<li><tt>:foreign_key</tt> - specify the foreign key used for the association.
By default this is guessed to be the name of this class in lower-case and
<tt>_id</tt> suffixed. So a <tt>Person</tt> class that makes a <tt><a
href="ClassMethods.html#M001271">has_and_belongs_to_many</a></tt>
association will use <tt>person_id</tt> as the default
<tt>foreign_key</tt>.

</li>
<li><tt>:association_foreign_key</tt> - specify the association foreign key
used for the association. By default this is guessed to be the name of the
associated class in lower-case and <tt>_id</tt> suffixed. So if the
associated class is <tt>Project</tt>, the <tt><a
href="ClassMethods.html#M001271">has_and_belongs_to_many</a></tt>
association will use <tt>project_id</tt> as the default association
<tt>foreign_key</tt>.

</li>
<li><tt>:conditions</tt> - specify the conditions that the associated object
must meet in order to be included as a <tt>WHERE</tt> SQL fragment, such as
<tt>authorized = 1</tt>.

</li>
<li><tt>:order</tt> - specify the order in which the associated objects are
returned as an <tt>ORDER BY</tt> SQL fragment, such as <tt>last_name,
first_name DESC</tt>

</li>
<li><tt>:uniq</tt> - if set to <tt>true</tt>, duplicate associated objects will
be ignored by accessors and query methods

</li>
<li><tt>:finder_sql</tt> - overwrite the default generated SQL statement used
to fetch the association with a manual statement

</li>
<li><tt>:delete_sql</tt> - overwrite the default generated SQL statement used
to remove links between the associated classes with a manual statement

</li>
<li><tt>:insert_sql</tt> - overwrite the default generated SQL statement used
to add links between the associated classes with a manual statement

</li>
<li><tt>:extend</tt> - anonymous module for extending the proxy, see
&quot;Association extensions&quot;.

</li>
<li><tt>:include</tt> - specify second-order associations that should be eager
loaded when the collection is loaded.

</li>
<li><tt>:group</tt>: An attribute name by which the result should be grouped.
Uses the <tt>GROUP BY</tt> SQL-clause.

</li>
<li><tt>:limit</tt>: An integer determining the limit on the number of rows
that should be returned.

</li>
<li><tt>:offset</tt>: An integer determining the offset from where the rows
should be fetched. So at 5, it would skip the first 4 rows.

</li>
<li><tt>:select</tt>: By default, this is <tt>*</tt> as in <tt>SELECT *
FROM</tt>, but can be changed if, for example, you want to do a join but
not include the joined columns.

</li>
<li><tt>:readonly</tt> - if set to <tt>true</tt>, all the associated objects
are readonly through the association.

</li>
</ul>
<p>
Option examples:
</p>
<pre>
  has_and_belongs_to_many :projects
  has_and_belongs_to_many :projects, :include =&gt; [ :milestones, :manager ]
  has_and_belongs_to_many :nations, :class_name =&gt; &quot;Country&quot;
  has_and_belongs_to_many :categories, :join_table =&gt; &quot;prods_cats&quot;
  has_and_belongs_to_many :categories, :readonly =&gt; true
  has_and_belongs_to_many :active_projects, :join_table =&gt; 'developers_projects', :delete_sql =&gt;
  'DELETE FROM developers_projects WHERE active=1 AND developer_id = #{id} AND project_id = #{record.id}'
</pre>

<p class="source_link" id="M001271-show-link"><a onclick="toggle('M001271-source'); toggleText('M001271-link'); return false;" href="#" id="M001271-link">Show source...</a></p><div class="source" id="M001271-source"><pre>      <span class="ruby-comment cmt"># File vendor/rails/activerecord/lib/active_record/associations.rb, line 993</span>
 993:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">has_and_belongs_to_many</span>(<span class="ruby-identifier">association_id</span>, <span class="ruby-identifier">options</span> = {}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">extension</span>)
 994:         <span class="ruby-identifier">reflection</span> = <span class="ruby-identifier">create_has_and_belongs_to_many_reflection</span>(<span class="ruby-identifier">association_id</span>, <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">extension</span>)
 995: 
 996:         <span class="ruby-identifier">add_multiple_associated_save_callbacks</span>(<span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">name</span>)
 997:         <span class="ruby-identifier">collection_accessor_methods</span>(<span class="ruby-identifier">reflection</span>, <span class="ruby-constant">HasAndBelongsToManyAssociation</span>)
 998: 
 999:         <span class="ruby-comment cmt"># Don't use a before_destroy callback since users' before_destroy</span>
1000:         <span class="ruby-comment cmt"># callbacks will be executed after the association is wiped out.</span>
1001:         <span class="ruby-identifier">old_method</span> = <span class="ruby-node">&quot;destroy_without_habtm_shim_for_#{reflection.name}&quot;</span>
1002:         <span class="ruby-identifier">class_eval</span> <span class="ruby-value str">&quot;alias_method :\#{old_method}, :destroy_without_callbacks\ndef destroy_without_callbacks\n\#{reflection.name}.clear\n\#{old_method}\nend\n&quot;</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">method_defined?</span>(<span class="ruby-identifier">old_method</span>)
1003: 
1004:         <span class="ruby-identifier">add_association_callbacks</span>(<span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">name</span>, <span class="ruby-identifier">options</span>)
1005:       <span class="ruby-keyword kw">end</span></pre></div>
</div>

<a class="small" name="M001268"><br/></a>
<div class="method_block"><h3>
<a href='#M001268'>


has_many

(association_id, options = {}, &amp;extension)

</a>
</h3>
<p>
Adds the following methods for retrieval and query of collections of
associated objects: <tt>collection</tt> is replaced with the symbol passed
as the first argument, so <tt><a
href="ClassMethods.html#M001268">has_many</a> :clients</tt> would add among
others <tt>clients.empty?</tt>.
</p>
<ul>
<li><tt>collection(force_reload = false)</tt> - returns an array of all the
associated objects. An empty array is returned if none are found.

</li>
<li><tt>collection&lt;&lt;(object, &#8230;)</tt> - adds one or more objects to
the collection by setting their foreign keys to the collection&#8216;s
primary key.

</li>
<li><tt>collection.delete(object, &#8230;)</tt> - removes one or more objects
from the collection by setting their foreign keys to NULL. This will also
destroy the objects if they&#8216;re declared as <tt><a
href="ClassMethods.html#M001270">belongs_to</a></tt> and dependent on this
model.

</li>
<li><tt>collection=objects</tt> - replaces the collections content by deleting
and adding objects as appropriate.

</li>
<li><tt>collection_singular_ids</tt> - returns an array of the associated
objects&#8217; ids

</li>
<li><tt>collection_singular_ids=ids</tt> - replace the collection with the
objects identified by the primary keys in <tt>ids</tt>

</li>
<li><tt>collection.clear</tt> - removes every object from the collection. This
destroys the associated objects if they are associated with <tt>:dependent
=&gt; :destroy</tt>, deletes them directly from the database if
<tt>:dependent =&gt; :delete_all</tt>, otherwise sets their foreign keys to
NULL.

</li>
<li><tt>collection.empty?</tt> - returns <tt>true</tt> if there are no
associated objects.

</li>
<li><tt>collection.size</tt> - returns the number of associated objects.

</li>
<li><tt>collection.find</tt> - finds an associated object according to the same
rules as <a href="../Base.html#M001539">Base.find</a>.

</li>
<li><tt>collection.build(attributes = {}, &#8230;)</tt> - returns one or more
new objects of the collection type that have been instantiated with
<tt>attributes</tt> and linked to this object through a foreign key, but
have not yet been saved. *Note:* This only works if an associated object
already exists, not if it&#8216;s <tt>nil</tt>!

</li>
<li><tt>collection.create(attributes = {})</tt> - returns a new object of the
collection type that has been instantiated with <tt>attributes</tt>, linked
to this object through a foreign key, and that has already been saved (if
it passed the validation). *Note:* This only works if an associated object
already exists, not if it&#8216;s <tt>nil</tt>!

</li>
</ul>
<p>
Example: A <tt>Firm</tt> class declares <tt><a
href="ClassMethods.html#M001268">has_many</a> :clients</tt>, which will
add:
</p>
<ul>
<li><tt>Firm#clients</tt> (similar to <tt>Clients.find :all, :conditions =&gt;
&quot;firm_id = #{id}&quot;</tt>)

</li>
<li><tt>Firm#clients&lt;&lt;</tt>

</li>
<li><tt>Firm#clients.delete</tt>

</li>
<li><tt>Firm#clients=</tt>

</li>
<li><tt>Firm#client_ids</tt>

</li>
<li><tt>Firm#client_ids=</tt>

</li>
<li><tt>Firm#clients.clear</tt>

</li>
<li><tt>Firm#clients.empty?</tt> (similar to <tt>firm.clients.size == 0</tt>)

</li>
<li><tt>Firm#clients.size</tt> (similar to <tt>Client.count &quot;firm_id =
#{id}&quot;</tt>)

</li>
<li><tt>Firm#clients.find</tt> (similar to <tt>Client.find(id, :conditions
=&gt; &quot;firm_id = #{id}&quot;)</tt>)

</li>
<li><tt>Firm#clients.build</tt> (similar to <tt>Client.new(&quot;firm_id&quot;
=&gt; id)</tt>)

</li>
<li><tt>Firm#clients.create</tt> (similar to <tt>c =
Client.new(&quot;firm_id&quot; =&gt; id); c.save; c</tt>)

</li>
</ul>
<p>
The declaration can also include an options hash to specialize the behavior
of the association.
</p>
<p>
Options are:
</p>
<ul>
<li><tt>:class_name</tt> - specify the class name of the association. Use it
only if that name can&#8216;t be inferred from the association name. So
<tt><a href="ClassMethods.html#M001268">has_many</a> :products</tt> will by
default be linked to the <tt>Product</tt> class, but if the real class name
is <tt>SpecialProduct</tt>, you&#8216;ll have to specify it with this
option.

</li>
<li><tt>:conditions</tt> - specify the conditions that the associated objects
must meet in order to be included as a <tt>WHERE</tt> SQL fragment, such as
<tt>price &gt; 5 AND name LIKE &#8216;B%&#8217;</tt>.

</li>
<li><tt>:order</tt> - specify the order in which the associated objects are
returned as an <tt>ORDER BY</tt> SQL fragment, such as <tt>last_name,
first_name DESC</tt>

</li>
<li><tt>:foreign_key</tt> - specify the foreign key used for the association.
By default this is guessed to be the name of this class in lower-case and
<tt>_id</tt> suffixed. So a <tt>Person</tt> class that makes a <tt><a
href="ClassMethods.html#M001268">has_many</a></tt> association will use
<tt>person_id</tt> as the default <tt>foreign_key</tt>.

</li>
<li><tt>:dependent</tt> - if set to <tt>:destroy</tt> all the associated
objects are destroyed alongside this object by calling their destroy
method. If set to <tt>:delete_all</tt> all associated objects are deleted
<b>without</b> calling their destroy method. If set to <tt>:nullify</tt>
all associated objects&#8217; foreign keys are set to <tt>NULL</tt>
<b>without</b> calling their save callbacks.

</li>
<li><tt>:finder_sql</tt> - specify a complete SQL statement to fetch the
association. This is a good way to go for complex associations that depend
on multiple tables. Note: When this option is used,
<tt>find_in_collection</tt> is <em>not</em> added.

</li>
<li><tt>:counter_sql</tt> - specify a complete SQL statement to fetch the size
of the association. If <tt>:finder_sql</tt> is specified but not
<tt>:counter_sql</tt>, <tt>:counter_sql</tt> will be generated by replacing
<tt>SELECT &#8230; FROM</tt> with <tt>SELECT COUNT(*) FROM</tt>.

</li>
<li><tt>:extend</tt> - specify a named module for extending the proxy. See
&quot;Association extensions&quot;.

</li>
<li><tt>:include</tt> - specify second-order associations that should be eager
loaded when the collection is loaded.

</li>
<li><tt>:group</tt>: An attribute name by which the result should be grouped.
Uses the <tt>GROUP BY</tt> SQL-clause.

</li>
<li><tt>:limit</tt>: An integer determining the limit on the number of rows
that should be returned.

</li>
<li><tt>:offset</tt>: An integer determining the offset from where the rows
should be fetched. So at 5, it would skip the first 4 rows.

</li>
<li><tt>:select</tt>: By default, this is <tt>*</tt> as in <tt>SELECT *
FROM</tt>, but can be changed if you, for example, want to do a join but
not include the joined columns.

</li>
<li><tt>:as</tt>: Specifies a polymorphic interface (See <tt><a
href="ClassMethods.html#M001270">belongs_to</a></tt>).

</li>
<li><tt>:through</tt>: Specifies a Join Model through which to perform the
query. Options for <tt>:class_name</tt> and <tt>:foreign_key</tt> are
ignored, as the association uses the source reflection. You can only use a
<tt>:through</tt> query through a <tt><a
href="ClassMethods.html#M001270">belongs_to</a></tt> or <tt><a
href="ClassMethods.html#M001268">has_many</a></tt> association on the join
model.

</li>
<li><tt>:source</tt>: Specifies the source association name used by <tt><a
href="ClassMethods.html#M001268">has_many</a> :through</tt> queries. Only
use it if the name cannot be inferred from the association. <tt><a
href="ClassMethods.html#M001268">has_many</a> :subscribers, :through =&gt;
:subscriptions</tt> will look for either <tt>:subscribers</tt> or
<tt>:subscriber</tt> on <tt>Subscription</tt>, unless a <tt>:source</tt> is
given.

</li>
<li><tt>:source_type</tt>: Specifies type of the source association used by
<tt><a href="ClassMethods.html#M001268">has_many</a> :through</tt> queries
where the source association is a polymorphic <tt><a
href="ClassMethods.html#M001270">belongs_to</a></tt>.

</li>
<li><tt>:uniq</tt> - if set to <tt>true</tt>, duplicates will be omitted from
the collection. Useful in conjunction with <tt>:through</tt>.

</li>
<li><tt>:readonly</tt> - if set to <tt>true</tt>, all the associated objects
are readonly through the association.

</li>
</ul>
<p>
Option examples:
</p>
<pre>
  has_many :comments, :order =&gt; &quot;posted_on&quot;
  has_many :comments, :include =&gt; :author
  has_many :people, :class_name =&gt; &quot;Person&quot;, :conditions =&gt; &quot;deleted = 0&quot;, :order =&gt; &quot;name&quot;
  has_many :tracks, :order =&gt; &quot;position&quot;, :dependent =&gt; :destroy
  has_many :comments, :dependent =&gt; :nullify
  has_many :tags, :as =&gt; :taggable
  has_many :reports, :readonly =&gt; true
  has_many :subscribers, :through =&gt; :subscriptions, :source =&gt; :user
  has_many :subscribers, :class_name =&gt; &quot;Person&quot;, :finder_sql =&gt;
      'SELECT DISTINCT people.* ' +
      'FROM people p, post_subscriptions ps ' +
      'WHERE ps.post_id = #{id} AND ps.person_id = p.id ' +
      'ORDER BY p.first_name'
</pre>

<p class="source_link" id="M001268-show-link"><a onclick="toggle('M001268-source'); toggleText('M001268-link'); return false;" href="#" id="M001268-link">Show source...</a></p><div class="source" id="M001268-source"><pre>     <span class="ruby-comment cmt"># File vendor/rails/activerecord/lib/active_record/associations.rb, line 688</span>
688:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">has_many</span>(<span class="ruby-identifier">association_id</span>, <span class="ruby-identifier">options</span> = {}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">extension</span>)
689:         <span class="ruby-identifier">reflection</span> = <span class="ruby-identifier">create_has_many_reflection</span>(<span class="ruby-identifier">association_id</span>, <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">extension</span>)
690: 
691:         <span class="ruby-identifier">configure_dependency_for_has_many</span>(<span class="ruby-identifier">reflection</span>)
692: 
693:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:through</span>]
694:           <span class="ruby-identifier">collection_accessor_methods</span>(<span class="ruby-identifier">reflection</span>, <span class="ruby-constant">HasManyThroughAssociation</span>, <span class="ruby-keyword kw">false</span>)
695:         <span class="ruby-keyword kw">else</span>
696:           <span class="ruby-identifier">add_multiple_associated_save_callbacks</span>(<span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">name</span>)
697:           <span class="ruby-identifier">add_association_callbacks</span>(<span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">name</span>, <span class="ruby-identifier">reflection</span>.<span class="ruby-identifier">options</span>)
698:           <span class="ruby-identifier">collection_accessor_methods</span>(<span class="ruby-identifier">reflection</span>, <span class="ruby-constant">HasManyAssociation</span>)
699:         <span class="ruby-keyword kw">end</span>
700:       <span class="ruby-keyword kw">end</span></pre></div>
</div>

<a class="small" name="M001269"><br/></a>
<div class="method_block"><h3>
<a href='#M001269'>


has_one

(association_id, options = {})

</a>
</h3>
<p>
Adds the following methods for retrieval and query of a single associated
object: <tt>association</tt> is replaced with the symbol passed as the
first argument, so <tt><a href="ClassMethods.html#M001269">has_one</a>
:manager</tt> would add among others <tt>manager.nil?</tt>.
</p>
<ul>
<li><tt>association(force_reload = false)</tt> - returns the associated object.
<tt>nil</tt> is returned if none is found.

</li>
<li><tt>association=(associate)</tt> - assigns the associate object, extracts
the primary key, sets it as the foreign key, and saves the associate
object.

</li>
<li><tt>association.nil?</tt> - returns <tt>true</tt> if there is no associated
object.

</li>
<li><tt>build_association(attributes = {})</tt> - returns a new object of the
associated type that has been instantiated with <tt>attributes</tt> and
linked to this object through a foreign key, but has not yet been saved.
Note: This ONLY works if an association already exists. It will NOT work if
the association is <tt>nil</tt>.

</li>
<li><tt>create_association(attributes = {})</tt> - returns a new object of the
associated type that has been instantiated with <tt>attributes</tt>, linked
to this object through a foreign key, and that has already been saved (if
it passed the validation).

</li>
</ul>
<p>
Example: An Account class declares <tt><a
href="ClassMethods.html#M001269">has_one</a> :beneficiary</tt>, which will
add:
</p>
<ul>
<li><tt>Account#beneficiary</tt> (similar to <tt>Beneficiary.find(:first,
:conditions =&gt; &quot;account_id = #{id}&quot;)</tt>)

</li>
<li><tt>Account#beneficiary=(beneficiary)</tt> (similar to
<tt>beneficiary.account_id = account.id; beneficiary.save</tt>)

</li>
<li><tt>Account#beneficiary.nil?</tt>

</li>
<li><tt>Account#build_beneficiary</tt> (similar to
<tt>Beneficiary.new(&quot;account_id&quot; =&gt; id)</tt>)

</li>
<li><tt>Account#create_beneficiary</tt> (similar to <tt>b =
Beneficiary.new(&quot;account_id&quot; =&gt; id); b.save; b</tt>)

</li>
</ul>
<p>
The declaration can also include an options hash to specialize the behavior
of the association.
</p>
<p>
Options are:
</p>
<ul>
<li><tt>:class_name</tt> - specify the class name of the association. Use it
only if that name can&#8216;t be inferred from the association name. So
<tt><a href="ClassMethods.html#M001269">has_one</a> :manager</tt> will by
default be linked to the <tt>Manager</tt> class, but if the real class name
is <tt>Person</tt>, you&#8216;ll have to specify it with this option.

</li>
<li><tt>:conditions</tt> - specify the conditions that the associated object
must meet in order to be included as a <tt>WHERE</tt> SQL fragment, such as
<tt>rank = 5</tt>.

</li>
<li><tt>:order</tt> - specify the order in which the associated objects are
returned as an <tt>ORDER BY</tt> SQL fragment, such as <tt>last_name,
first_name DESC</tt>

</li>
<li><tt>:dependent</tt> - if set to <tt>:destroy</tt>, the associated object is
destroyed when this object is. If set to <tt>:delete</tt>, the associated
object is deleted <b>without</b> calling its destroy method. If set to
<tt>:nullify</tt>, the associated object&#8216;s foreign key is set to
<tt>NULL</tt>. Also, association is assigned.

</li>
<li><tt>:foreign_key</tt> - specify the foreign key used for the association.
By default this is guessed to be the name of this class in lower-case and
<tt>_id</tt> suffixed. So a <tt>Person</tt> class that makes a <tt><a
href="ClassMethods.html#M001269">has_one</a></tt> association will use
<tt>person_id</tt> as the default <tt>foreign_key</tt>.

</li>
<li><tt>:include</tt> - specify second-order associations that should be eager
loaded when this object is loaded.

</li>
<li><tt>:as</tt>: Specifies a polymorphic interface (See <tt><a
href="ClassMethods.html#M001270">belongs_to</a></tt>).

</li>
<li><tt>:readonly</tt> - if set to <tt>true</tt>, the associated object is
readonly through the association.

</li>
</ul>
<p>
Option examples:
</p>
<pre>
  has_one :credit_card, :dependent =&gt; :destroy  # destroys the associated credit card
  has_one :credit_card, :dependent =&gt; :nullify  # updates the associated records foreign key value to NULL rather than destroying it
  has_one :last_comment, :class_name =&gt; &quot;Comment&quot;, :order =&gt; &quot;posted_on&quot;
  has_one :project_manager, :class_name =&gt; &quot;Person&quot;, :conditions =&gt; &quot;role = 'project_manager'&quot;
  has_one :attachment, :as =&gt; :attachable
  has_one :boss, :readonly =&gt; :true
</pre>

<p class="source_link" id="M001269-show-link"><a onclick="toggle('M001269-source'); toggleText('M001269-link'); return false;" href="#" id="M001269-link">Show source...</a></p><div class="source" id="M001269-source"><pre>     <span class="ruby-comment cmt"># File vendor/rails/activerecord/lib/active_record/associations.rb, line 749</span>
749:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">has_one</span>(<span class="ruby-identifier">association_id</span>, <span class="ruby-identifier">options</span> = {})
750:         <span class="ruby-identifier">reflection</span> = <span class="ruby-identifier">create_has_one_reflection</span>(<span class="ruby-identifier">association_id</span>, <span class="ruby-identifier">options</span>)
751: 
752:         <span class="ruby-identifier">ivar</span> = <span class="ruby-node">&quot;@#{reflection.name}&quot;</span>
753: 
754:         <span class="ruby-identifier">method_name</span> = <span class="ruby-node">&quot;has_one_after_save_for_#{reflection.name}&quot;</span>.<span class="ruby-identifier">to_sym</span>
755:         <span class="ruby-identifier">define_method</span>(<span class="ruby-identifier">method_name</span>) <span class="ruby-keyword kw">do</span>
756:           <span class="ruby-identifier">association</span> = <span class="ruby-identifier">instance_variable_get</span>(<span class="ruby-node">&quot;#{ivar}&quot;</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">instance_variable_defined?</span>(<span class="ruby-node">&quot;#{ivar}&quot;</span>)
757: 
758:           <span class="ruby-keyword kw">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">association</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">new_record?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">association</span>.<span class="ruby-identifier">new_record?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">association</span>[<span class="ruby-node">&quot;#{reflection.primary_key_name}&quot;</span>] <span class="ruby-operator">!=</span> <span class="ruby-identifier">id</span>)
759:             <span class="ruby-identifier">association</span>[<span class="ruby-node">&quot;#{reflection.primary_key_name}&quot;</span>] = <span class="ruby-identifier">id</span>
760:             <span class="ruby-identifier">association</span>.<span class="ruby-identifier">save</span>(<span class="ruby-keyword kw">true</span>)
761:           <span class="ruby-keyword kw">end</span>
762:         <span class="ruby-keyword kw">end</span>
763:         <span class="ruby-identifier">after_save</span> <span class="ruby-identifier">method_name</span>
764: 
765:         <span class="ruby-identifier">association_accessor_methods</span>(<span class="ruby-identifier">reflection</span>, <span class="ruby-constant">HasOneAssociation</span>)
766:         <span class="ruby-identifier">association_constructor_method</span>(<span class="ruby-identifier">:build</span>,  <span class="ruby-identifier">reflection</span>, <span class="ruby-constant">HasOneAssociation</span>)
767:         <span class="ruby-identifier">association_constructor_method</span>(<span class="ruby-identifier">:create</span>, <span class="ruby-identifier">reflection</span>, <span class="ruby-constant">HasOneAssociation</span>)
768: 
769:         <span class="ruby-identifier">configure_dependency_for_has_one</span>(<span class="ruby-identifier">reflection</span>)
770:       <span class="ruby-keyword kw">end</span></pre></div>
</div>





</div><div class="clear" id="footer">Generated on Jan 21, 2008 / Allison 2 &copy; 2007 <a href="http://cloudbur.st">Cloudburst, LLC</a></div></div></body></html>